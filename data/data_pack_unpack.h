//
// This file is automatically generated.
// Please do not edit by hand, any change
// to this file will be lost quickly
//

#ifndef __DUC_H
#define __DUC_H


#include <vector>
#include <string>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <iostream>
#include <sstream>
#include <map>



#include "nb_id.h"
#include "nb_bridge_data_desc.h"

const std::string hexDigits = "0123456789ABCDEF";

enum PACKTYPE {
  EMPTY, BYTEARRAY, INTARRAY, STRINGARRAY, STRUCT, STRUCTARRAY
};

class Packer;
class XPacker;
class Unpacker;

class DUCData {

public:

  inline static DUCData* create(int32_t id);

  virtual DUCData* clone() = 0;

  virtual int32_t getTypeId() = 0;

  virtual std::string getTypeName() = 0;

  virtual void packSub(Packer& p) = 0;

  virtual void unpackSub(Unpacker& u) = 0;

  virtual void streamSub(XPacker& u) = 0;

  virtual ~DUCData() {
  }
};

class UBuffer {

private:
  uint8_t* d;
  int32_t position;
  int32_t s;

public:
  UBuffer() {
    this->d = 0;
    this->position = 0;
    this->s = 0;
  }

  UBuffer(uint8_t* const data, int32_t size) {
    this->position = 0;
    copy(data, size);
  }

  UBuffer(const UBuffer& o) {
    copy(o.d, o.s);
    this->position = o.position;
  }

  ~UBuffer() {
     delete[] this->d;
     this->d = NULL;  
  }

  UBuffer& operator=(const UBuffer& o) {
    if (this == &o)
      return *this;

    copy(o.d, o.s);
    this->position = o.position;
    return *this;
  }

  void setData(const uint8_t* data, int32_t size) {
    this->position = 0;
    copy(data, size);
  }

  void reset() {
    this->position = 0;
  }

  void add(int32_t data) {
    check(sizeof(int32_t));
    d[position++] = data & 0xff;
    d[position++] = (data >> 8) & 0xff;
    d[position++] = (data >> 16) & 0xff;
    d[position++] = (data >> 24) & 0xff;
  }

  void add(const uint8_t* data, int32_t size) {
    int ex = ((size + 3) / 4) * 4;
    check(ex);
    for (int32_t i = 0; i < size; i++) {
      d[i + position] = data[i];
    }
    position += ex;
  }

  int32_t takeInt() {
    uint8_t* c = d + position;
    int32_t res = (c[3] << 24) | ((c[2] << 16) & 0xFF0000) | ((c[1] << 8)
        & 0xFF00) | (c[0] & 0xFF);
    position += 4;
    return res;
  }

  uint8_t* const takeBytes(int32_t size) {
    uint8_t* res = d + position;
    position += ((size + 3) / 4) * 4;
    return res;
  }

  void printData() {
    std::cout << "Total length: " << position;

    unsigned int p = 0;
    int size = position / 4;
    for (int i = 0; i < size; ++i) {
      if (i % 5 == 0) {
        std::cout << std::endl;
      }
      uint8_t* c = d + p;
      int32_t res = (c[3] << 24) | ((c[2] << 16) & 0xFF0000) | ((c[1] << 8)
          & 0xFF00) | (c[0] & 0xFF);
      printf("%11d/%8x,", (int32_t) res, (uint32_t) res);
      p += 4;
    }
    std::cout << std::endl << " --------- end of dump ----------" << std::endl;
  }

  int32_t size() {
    return position;
  }

  uint8_t* data() {
    return d;
  }

private:
  void copy(const uint8_t* s, int size) {
    this->d = new uint8_t[size];
    this->s = size;
    memcpy(this->d, s, size);
    this->position = size;
  }

  void check(int32_t size) {
    if (size + position < s) {
      return;
    }
    int32_t ex = size < 1024 ? 1024 : size;
    if (ex < s) {
      ex = s;
    }
    ex += s;
    uint8_t* nb = new uint8_t[ex];
    if (d) {
      memcpy(nb, this->d, s);
      delete[] this->d;
    }
    this->d = nb;
    this->s = ex;
  }
};

class Packer {

private:
  UBuffer buf;

public:
  Packer() {
  }

  UBuffer& data() {
    return buf;
  }

  void pack(DUCData& c) {
    buf.add((int32_t) STRUCT);
    buf.add(c.getTypeId());
    c.packSub(*this);
  }

  void pack(DUCData* c) {
    buf.add((int32_t) STRUCT);
    buf.add(c->getTypeId());
    c->packSub(*this);
  }

  void pack(std::string& str) {
    pack((uint8_t*) str.c_str(), str.size());
  }

  void pack(std::vector<uint8_t>& d) {
    pack(&d[0], d.size());
  }

  void pack(int32_t c) {
    buf.add(c);
  }

  void pack(float f) {
    pack((int32_t)(f * 100000));
  }

  void pack(bool b) {
    pack((int32_t)(b ? 1 : 0));
  }

  template<typename T>
  void pack(std::vector<T>& c) {
    pack(c, STRUCTARRAY);
  }

  void pack(std::vector<std::string>& c) {
    pack(c, STRINGARRAY);
  }

  void pack(std::vector<int32_t>& c) {
    pack(c, INTARRAY);
  }

  void pack(std::vector<float>& c) {
    pack(c, INTARRAY);
  }

  void pack(std::vector<bool>& c) {
    pack(c, INTARRAY);
  }

  ~Packer() {
  }

private:
  void pack(uint8_t* d, int32_t s) {
    buf.add((int32_t) BYTEARRAY);
    buf.add(s);
    buf.add(d, s);
  }

  template<typename T>
  void pack(std::vector<T>& c, PACKTYPE type) {
    buf.add((int32_t) type);
    buf.add(c.size());
    if (c.size() == 0) {
      return;
    }
    for (unsigned int i = 0; i < c.size(); ++i) {
      pack(c[i]);
    }
  }
};

class XE {
private:
  std::map<std::string, std::string> attributes;
  std::string tag;

public:
  XE() {
    tag = "error";
  }

  XE(std::string aTag) {
    tag = aTag;
  }

  void setTag(std::string aTag) {
    tag = aTag;
  }

  void addAttribute(const std::string& name, const std::string& value) {
    attributes[name] = value;
  }

  std::string const head() {
    std::string res = "";
    res.append("<").append(tag);
    for (std::map<std::string, std::string>::iterator p = attributes.begin(); p
        != attributes.end(); p++) {
      res.append(" ").append(p->first).append("=\"").append(p->second).append(
          "\"");
    }
    res.append(">");
    return res;
  }

  std::string const tail() {
    return "</" + tag + ">";
  }
};

class XPacker {

private:
  std::ostream& ost;
  std::string prepend;
  std::string pre;
  bool tight;

public:

  XPacker(std::ostream* aStream) :
    ost(*aStream) {
    init("    ", false);
  }

  XPacker(std::ostream* aStream, bool aTight) :
    ost(*aStream) {
    init("    ", aTight);
  }

  XPacker(std::ostream* aStream, const std::string& aPrepend) :
    ost(*aStream) {
    init(aPrepend, false);
  }

  XPacker(std::ostream* aStream, const std::string& aPrepend, bool aTight) :
    ost(*aStream) {
    init(aPrepend, aTight);
  }

  void pack(std::string name, DUCData& c) {
    XE xe("struct");
    xe.addAttribute("name", name);
    xe.addAttribute("type", c.getTypeName());
    xe.addAttribute("typeId", "" + c.getTypeId());
    ost << prepend << xe.head();

    newLine();
    einruecken();

    c.streamSub(*this);

    ausruecken();
    ost << prepend << xe.tail();
    newLine();
  }

  void pack(const std::string& name, DUCData* c) {
    pack(name, *c);
  }

  void pack(const std::string& name, const std::string& str) {
    XE xe("string");
    xe.addAttribute("name", name);
    data(xe, str);
  }

  void pack(const std::string& name, std::vector<uint8_t>& d) {
    std::vector<std::string>* dd = convert(d);
    XE xe("bytearray");
    xe.addAttribute("name", name);
    ost << prepend << xe.head();

    newLine();
    einruecken();

    for (uint32_t i = 0; i < dd->size(); ++i) {
      ost << prepend << (*dd)[i];
      newLine();
    }

    ausruecken();
    ost << prepend << xe.tail();
    newLine();

    delete dd;
  }

  void pack(const std::string& name, int32_t c) {
    XE xe("int");
    xe.addAttribute("name", name);
    data(xe, c);
  }

  void pack(const std::string& name, float f) {
    XE xe("int");
    xe.addAttribute("name", name);
    data(xe, (int32_t)(f * 100000));
  }

  void pack(const std::string& name, bool b) {
    XE xe("int");
    xe.addAttribute("name", name);
    data(xe, (int32_t)(b ? 1 : 0));
  }

  template<typename T>
  void pack(const std::string& name, std::vector<T>& c) {
    pack(name, c, "structarray");
  }

  void pack(const std::string& name, std::vector<std::string>& c) {
    pack(name, c, "stringarray");
  }

  void pack(const std::string& name, std::vector<int32_t>& c) {
    pack(name, c, "intarry");
  }

  void pack(const std::string& name, std::vector<float>& c) {
    pack(name, c, "intarry");
  }

  void pack(const std::string& name, std::vector<bool>& c) {
    pack(name, c, "intarry");
  }

  ~XPacker() {
  }

  static std::vector<std::string>* convert(const std::vector<uint8_t>& d) {
    std::vector<std::string>* res = new std::vector<std::string>();
    std::string buf;
    for (uint32_t i = 0; i < d.size(); ++i) {
      buf.append(hexDigits[(d[i] >> 4) & 0xF], 1);
      buf.append(hexDigits[d[i] & 0xF], 1);
      if ((i % 32) == 31) {
        res->push_back(buf);
        buf = "";
      }
    }
    if (buf.size() > 0) {
      res->push_back(buf);
    }
    return res;
  }

  template<typename T>
  static std::string convert(T d) {
    std::ostringstream oss;
    oss << d;
    return oss.str();
  }

private:

  template<typename T>
  void pack(const std::string& name, std::vector<T>& c, const std::string& type) {
    XE xe(type);
    xe.addAttribute("name", name);
    xe.addAttribute("length", convert(c.size()));

    ost << prepend << xe.head();

    newLine();
    einruecken();

    for (uint32_t i = 0; i < c.size(); ++i) {
      pack(convert(i), c[i]);
    }

    ausruecken();
    ost << prepend << xe.tail();
    newLine();
  }

  void newLine() {
    if (!tight) {
      ost << std::endl;
    }
  }

  void einruecken() {
    if (!tight) {
      prepend += pre;
    }
  }

  void ausruecken() {
    if (prepend.size() >= pre.size()) {
      prepend.erase(prepend.size() - pre.size());
    }
  }

  void init(const std::string& aPrepend, bool aTight) {
    prepend = "";
    tight = aTight;
    pre = aPrepend;
  }

  template<typename T>
  void data(XE& e, const T& data) {
    ost << prepend << e.head() << data << e.tail();
    newLine();
  }
};

class Unpacker {
private:
  UBuffer& buf;
  bool failed;

public:
  Unpacker(UBuffer& b) :
    buf(b) {
    buf.reset();
    failed = false;
  }

  DUCData* getData() {
    int32_t l = checkType(STRUCT);
    if (l < 0) {
      return 0;
    }
    DUCData* d = DUCData::create(l);
    d->unpackSub(*this);
    return d;
  }

  template<typename T>
  void unpack(T& c) {
    int32_t l = checkType(STRUCT);
    if (l < 0 || l != c.getTypeId()) {
      return;
    }
    c.unpackSub(*this);
  }

  template<typename T>
  void unpack(T* c) {
    unpack(*c);
  }

  void unpack(std::string& c) {
    int32_t l = checkType(BYTEARRAY);
    if (l < 0) {
      return;
    }
    c.assign((char*) buf.takeBytes(l), l);
  }

  void unpack(std::vector<uint8_t>& d) {
    int32_t l = checkType(BYTEARRAY);
    if (l < 0) {
      return;
    }
    uint8_t* x = buf.takeBytes(l);
    d.assign(x, x + l);
  }

  void unpack(std::vector<int32_t>& d) {
    int32_t l = checkType(INTARRAY);
    if (l < 0) {
      return;
    }
    for (int32_t i = 0; i < l; ++i) {
      d.push_back(buf.takeInt());
    }
  }

  void unpack(std::vector<bool>& d) {
    int32_t l = checkType(INTARRAY);
    if (l < 0) {
      return;
    }
    for (int32_t i = 0; i < l; ++i) {
      d.push_back(buf.takeInt() != 0);
    }
  }

  void unpack(std::vector<float>& d) {
    int32_t l = checkType(INTARRAY);
    if (l < 0) {
      return;
    }
    for (int32_t i = 0; i < l; ++i) {
      d.push_back(0.00001 * buf.takeInt());
    }
  }

  void unpack(int32_t& c) {
    c = buf.takeInt();
  }

  void unpack(float& f) {
    f = 0.00001 * buf.takeInt();
  }

  void unpack(bool& b) {
    b = buf.takeInt() != 0;
  }

  template<typename T>
  void unpack(std::vector<T>& c) {
    int32_t l = checkType(STRUCTARRAY);
    if (l < 0) {
      return;
    }
    c.resize(l);
    for (int32_t i = 0; i < l; ++i) {
      unpack(c[i]);
    }
  }

  template<typename T>
  void unpack(std::vector<T*>& c) {
    int32_t l = checkType(STRUCTARRAY);
    if (l < 0) {
      return;
    }
    c.resize(l);
    for (int32_t i = 0; i < l; ++i) {
      if (c[i] == 0) {
        c[i] = new T();
      }
      unpack(*c[i]);
    }
  }

private:
  int32_t checkType(PACKTYPE t) {
    if (failed) {
      return -1;
    }
    PACKTYPE x = (PACKTYPE) buf.takeInt();
    if (t != x) {
      failed = true;
      return -1;
    }
    return buf.takeInt();
  }
};

class AspectKeeper;
class GlyphProperties;
class ScaleFit;
class T3D;
class T3DFog;
class T3DLight;
class T3DPlacement;
class T3DVector;
class T3DWorld;
class TAbstractVisible;
class TAddNode;
class TAnimation;
class TAnimationTask;
class TArc;
class TArea;
class TAttachNode;
class TBehavior;
class TCell;
class TChannel;
class TChannelOperation;
class TChannelOperationResponse;
class TColor;
class TColorGradient;
class TCursor;
class TCurve;
class TDeleteNode;
class TEllipse;
class TFont;
class TGeneralCurve;
class TGesture;
class TGetResourcesFromUsr;
class TImage;
class TInformServer;
class TLine;
class TMIME;
class TMargin;
class TNone;
class TPath;
class TPenStroke;
class TPlacement;
class TPoint;
class TPolynomial;
class TRectangle;
class TReference;
class TReplaceNode;
class TResourceUnit;
class TResponse;
class TResponseClosure;
class TSelectionCriterion;
class TSize;
class TText;
class TTransformation;
class TUpdateNode;
class TUploadResources;

enum CAGType {
	CAGType_Add, CAGType_Intersect, CAGType_Subtract, CAGType_ExclusiveOr
};

enum ChannelResponseType {
	ChannelResponse_Error, ChannelResponse_OK
};

enum CursorType {
	Default_Cursor, Text_Cursor, Crosshair_Cursor, Hand_Cursor, Drag_Cursor, Drop_Cursor, NoDrop_Cursor, Wait_Cursor, IDle_Cursor, Custom_Cursor 
};

enum FillType {
	ShowAll, Differred
};

enum LayoutType {
	Left, Center, Right
};

enum RelationshipType {
	KeepLarge, KeepSmall, Disrelated
};

enum RotateExtentType {
	ZERO, X, XX, XXX
};

enum ScaleFitType {
	Scale_Tile, Scale_Center, Scale_Stretch
};

enum TArcClosedType {
	ArcClosedType_CHORD, ArcClosedType_OPEN, ArcClosedType_PIE
};

enum TChannelOperationType {
	ChannelOperation_Open, ChannelOperation_Create, ChannelOperation_Query, ChannelOperation_Close, ChannelOperation_Flush
};

enum TCurveType {
	Curve_QUAD, Curve_CUBIC, Curve_LINE, Curve_RECT, Curve_ELLIPSE, Curve_ARC, Curve_CUSTOM
};

enum TDashPattern {
	none, s_common, m_common, l_common, s_dot_dash, m_dot_dash, l_dot_dash
};

enum TFontName {
	Dialog, SansSerif, Serif, Monospaced, DialogInput
};

enum TGestureType {
	Start, PassingIn, PassingOut, Hover, Focus, Blur, Select, Unselect, Delete, Detail, Activate, Deactivate, DnD_Start, Drag, Grab, Release, Moving, Input, In, Out, Enlarge, Shrink, Any, Resize_Start, Resize_Release, DnD_Release, Wheel_Start, Wheel_Release, LDnD_Start, LDnD_Release, Refresh
};

enum TInterpolatedCalcModeType {
	Interpolation_Discrete, Interpolation_Linear, Interpolation_Paced, Interpolation_Spline
};

enum TModifier {
	Function, System, Root, Subject, Object, Lateral, Angular, Alternate
};

enum TPolynomialTypes {
	D1, Linear, Quad
};

enum TPostionType {
	TPostionType_Left_Up_In, TPostionType_Right_Up_In, TPostionType_Left_Down_In, TPostionType_Right_Down_In, TPostionType_Center_In, TPostionType_Left_Up_Out, TPostionType_Right_Up_Out, TPostionType_Left_Down_Out, TPostionType_Right_Down_Out, TPostionType_Center_Out
};

enum TResponseType {
	Response_Add, Response_Delete, Response_Replace, Response_Update, Response_Start_Animations, Response_Stop_Animations
};

enum TShapeType {
	Shape_GeneralCurve, Shape_Arc, Shape_Rectangle
};

enum TTimeUnit {
	NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS
};

enum TValueType {
	ValueType_Fixed, ValueType_Free, ValueType_Tight
};


//////////////////////////////////////////////////////////////

class AspectKeeper: public DUCData {

public:
	int32_t minAspectRatio;

	int32_t maxAspectRatio;

	int32_t xLoc;

	int32_t yLoc;

	std::string getTypeName() {
		return "AspectKeeper";
	}


	int32_t getTypeId() {
		return 37;
	}


	static int32_t getStaticId() {
		return 37;
	}


	AspectKeeper(): 
	minAspectRatio(0), maxAspectRatio(0), xLoc(-1), yLoc(-1) {
	}


	AspectKeeper(const AspectKeeper& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual AspectKeeper* clone() {
		AspectKeeper* res = new AspectKeeper();
		*res = *this;
		return res;
	}


	virtual AspectKeeper& operator =(const AspectKeeper& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~AspectKeeper() {
	}


	AspectKeeper(int32_t _minAspectRatio,  int32_t _maxAspectRatio,  int32_t _xLoc, 
	        int32_t _yLoc): 
	minAspectRatio(_minAspectRatio), maxAspectRatio(_maxAspectRatio), xLoc(_xLoc), yLoc(_yLoc) {
	}


	virtual void packSub(Packer& p) {
		p.pack(minAspectRatio);
		p.pack(maxAspectRatio);
		p.pack(xLoc);
		p.pack(yLoc);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(minAspectRatio);
		u.unpack(maxAspectRatio);
		u.unpack(xLoc);
		u.unpack(yLoc);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("minAspectRatio", minAspectRatio);
		p.pack("maxAspectRatio", maxAspectRatio);
		p.pack("xLoc", xLoc);
		p.pack("yLoc", yLoc);
	}



private:
	AspectKeeper& doCopy(const AspectKeeper& other) {
		minAspectRatio = other.minAspectRatio;
		maxAspectRatio = other.maxAspectRatio;
		xLoc = other.xLoc;
		yLoc = other.yLoc;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class ScaleFit: public DUCData {

public:
	ScaleFitType scaleFitType;

	int32_t offOneSide;

	int32_t offAnotherSide;

	std::string getTypeName() {
		return "ScaleFit";
	}


	int32_t getTypeId() {
		return 22;
	}


	static int32_t getStaticId() {
		return 22;
	}


	ScaleFit(): 
	scaleFitType(Scale_Center), offOneSide(0), offAnotherSide(0) {
	}


	ScaleFit(const ScaleFit& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual ScaleFit* clone() {
		ScaleFit* res = new ScaleFit();
		*res = *this;
		return res;
	}


	virtual ScaleFit& operator =(const ScaleFit& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~ScaleFit() {
	}


	ScaleFit(ScaleFitType _scaleFitType,  int32_t _offOneSide,  int32_t _offAnotherSide): 
	scaleFitType(_scaleFitType), offOneSide(_offOneSide), offAnotherSide(_offAnotherSide) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)scaleFitType);
		p.pack(offOneSide);
		p.pack(offAnotherSide);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddscaleFitType;
		u.unpack(ddscaleFitType);
		scaleFitType = (ScaleFitType)ddscaleFitType;
		u.unpack(offOneSide);
		u.unpack(offAnotherSide);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("scaleFitType", (int32_t)scaleFitType);
		p.pack("offOneSide", offOneSide);
		p.pack("offAnotherSide", offAnotherSide);
	}



private:
	ScaleFit& doCopy(const ScaleFit& other) {
		scaleFitType = other.scaleFitType;
		offOneSide = other.offOneSide;
		offAnotherSide = other.offAnotherSide;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class T3DVector: public DUCData {

public:
	int32_t x;

	int32_t y;

	int32_t z;

	std::string getTypeName() {
		return "T3DVector";
	}


	int32_t getTypeId() {
		return 46;
	}


	static int32_t getStaticId() {
		return 46;
	}


	T3DVector(): 
	x(0), y(0), z(0) {
	}


	T3DVector(const T3DVector& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual T3DVector* clone() {
		T3DVector* res = new T3DVector();
		*res = *this;
		return res;
	}


	virtual T3DVector& operator =(const T3DVector& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~T3DVector() {
	}


	T3DVector(int32_t _x,  int32_t _y,  int32_t _z): 
	x(_x), y(_y), z(_z) {
	}


	virtual void packSub(Packer& p) {
		p.pack(x);
		p.pack(y);
		p.pack(z);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(x);
		u.unpack(y);
		u.unpack(z);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("x", x);
		p.pack("y", y);
		p.pack("z", z);
	}



private:
	T3DVector& doCopy(const T3DVector& other) {
		x = other.x;
		y = other.y;
		z = other.z;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TAbstractVisible: public DUCData {

public:
	std::string getTypeName() {
		return "TAbstractVisible";
	}


	int32_t getTypeId() {
		return 1;
	}


	static int32_t getStaticId() {
		return 1;
	}


	TAbstractVisible() {
	}


	TAbstractVisible(const TAbstractVisible& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TAbstractVisible* clone() {
		TAbstractVisible* res = new TAbstractVisible();
		*res = *this;
		return res;
	}


	virtual TAbstractVisible& operator =(const TAbstractVisible& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TAbstractVisible() {
	}


	virtual void packSub(Packer& p) {
	}


	virtual void unpackSub(Unpacker& u) {
	}


	virtual void streamSub(XPacker& p) {
	}



private:
	TAbstractVisible& doCopy(const TAbstractVisible& other) {
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TAnimation: public DUCData {

public:
	int32_t beginWhenTime;

	int32_t endWhenTime;

	std::vector<TAnimationTask> task;

	std::vector<TAnimation> children;

	bool accumulate;

	int32_t repeatCount;

	TTimeUnit timeUnit;

	std::string getTypeName() {
		return "TAnimation";
	}


	int32_t getTypeId() {
		return 40;
	}


	static int32_t getStaticId() {
		return 40;
	}


	TAnimation(): 
	beginWhenTime(-1), endWhenTime(-1), accumulate(false), repeatCount(-1), timeUnit(SECONDS) {
	}


	TAnimation(const TAnimation& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TAnimation* clone() {
		TAnimation* res = new TAnimation();
		*res = *this;
		return res;
	}


	virtual TAnimation& operator =(const TAnimation& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TAnimation() {
	}


	TAnimation(int32_t _beginWhenTime,  int32_t _endWhenTime,  std::vector<TAnimationTask> _task, 
	        std::vector<TAnimation> _children,  bool _accumulate,  int32_t _repeatCount, 
	        TTimeUnit _timeUnit): 
	beginWhenTime(_beginWhenTime), endWhenTime(_endWhenTime), task(_task), children(_children), accumulate(_accumulate), repeatCount(_repeatCount), timeUnit(_timeUnit) {
	}


	virtual void packSub(Packer& p) {
		p.pack(beginWhenTime);
		p.pack(endWhenTime);
		p.pack(task);
		p.pack(children);
		p.pack(accumulate);
		p.pack(repeatCount);
		p.pack((int32_t)timeUnit);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(beginWhenTime);
		u.unpack(endWhenTime);
		u.unpack(task);
		u.unpack(children);
		u.unpack(accumulate);
		u.unpack(repeatCount);
		int32_t ddtimeUnit;
		u.unpack(ddtimeUnit);
		timeUnit = (TTimeUnit)ddtimeUnit;
	}


	virtual void streamSub(XPacker& p) {
		p.pack("beginWhenTime", beginWhenTime);
		p.pack("endWhenTime", endWhenTime);
		p.pack("task", task);
		p.pack("children", children);
		p.pack("accumulate", accumulate);
		p.pack("repeatCount", repeatCount);
		p.pack("timeUnit", (int32_t)timeUnit);
	}



private:
	TAnimation& doCopy(const TAnimation& other) {
		beginWhenTime = other.beginWhenTime;
		endWhenTime = other.endWhenTime;
		task = other.task;
		children = other.children;
		accumulate = other.accumulate;
		repeatCount = other.repeatCount;
		timeUnit = other.timeUnit;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TAnimationTask: public DUCData {

public:
	std::vector<TPlacement> values;

	TInterpolatedCalcModeType calcMode;

	std::vector<int32_t> keyTimes;

	std::vector<int32_t> keySplines;

	int32_t dur;

	std::string getTypeName() {
		return "TAnimationTask";
	}


	int32_t getTypeId() {
		return 41;
	}


	static int32_t getStaticId() {
		return 41;
	}


	TAnimationTask(): 
	calcMode(Interpolation_Linear), dur(-1) {
	}


	TAnimationTask(const TAnimationTask& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TAnimationTask* clone() {
		TAnimationTask* res = new TAnimationTask();
		*res = *this;
		return res;
	}


	virtual TAnimationTask& operator =(const TAnimationTask& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TAnimationTask() {
	}


	TAnimationTask(std::vector<TPlacement> _values,  TInterpolatedCalcModeType _calcMode, 
	        std::vector<int32_t> _keyTimes,  std::vector<int32_t> _keySplines,  int32_t _dur): 
	values(_values), calcMode(_calcMode), keyTimes(_keyTimes), keySplines(_keySplines), dur(_dur) {
	}


	virtual void packSub(Packer& p) {
		p.pack(values);
		p.pack((int32_t)calcMode);
		p.pack(keyTimes);
		p.pack(keySplines);
		p.pack(dur);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(values);
		int32_t ddcalcMode;
		u.unpack(ddcalcMode);
		calcMode = (TInterpolatedCalcModeType)ddcalcMode;
		u.unpack(keyTimes);
		u.unpack(keySplines);
		u.unpack(dur);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("values", values);
		p.pack("calcMode", (int32_t)calcMode);
		p.pack("keyTimes", keyTimes);
		p.pack("keySplines", keySplines);
		p.pack("dur", dur);
	}



private:
	TAnimationTask& doCopy(const TAnimationTask& other) {
		values = other.values;
		calcMode = other.calcMode;
		keyTimes = other.keyTimes;
		keySplines = other.keySplines;
		dur = other.dur;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TBehavior: public DUCData {

public:
	TGestureType gestureType;

	bool informServer;

	std::vector<TResponse> actionTypes;

	bool passThrough;

	std::string getTypeName() {
		return "TBehavior";
	}


	int32_t getTypeId() {
		return 33;
	}


	static int32_t getStaticId() {
		return 33;
	}


	TBehavior(): 
	gestureType(Start), informServer(true), passThrough(false) {
	}


	TBehavior(const TBehavior& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TBehavior* clone() {
		TBehavior* res = new TBehavior();
		*res = *this;
		return res;
	}


	virtual TBehavior& operator =(const TBehavior& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TBehavior() {
	}


	TBehavior(TGestureType _gestureType,  bool _informServer,  std::vector<TResponse> _actionTypes, 
	        bool _passThrough): 
	gestureType(_gestureType), informServer(_informServer), actionTypes(_actionTypes), passThrough(_passThrough) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)gestureType);
		p.pack(informServer);
		p.pack(actionTypes);
		p.pack(passThrough);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddgestureType;
		u.unpack(ddgestureType);
		gestureType = (TGestureType)ddgestureType;
		u.unpack(informServer);
		u.unpack(actionTypes);
		u.unpack(passThrough);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("gestureType", (int32_t)gestureType);
		p.pack("informServer", informServer);
		p.pack("actionTypes", actionTypes);
		p.pack("passThrough", passThrough);
	}



private:
	TBehavior& doCopy(const TBehavior& other) {
		gestureType = other.gestureType;
		informServer = other.informServer;
		actionTypes = other.actionTypes;
		passThrough = other.passThrough;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TChannelOperation: public DUCData {

public:
	TChannelOperationType operationType;

	std::vector<int32_t> channel_or_group_id;

	std::vector<TChannel> channels;

	std::vector<uint8_t> data;

	std::string getTypeName() {
		return "TChannelOperation";
	}


	int32_t getTypeId() {
		return 53;
	}


	static int32_t getStaticId() {
		return 53;
	}


	TChannelOperation(): 
	operationType(ChannelOperation_Open) {
	}


	TChannelOperation(const TChannelOperation& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TChannelOperation* clone() {
		TChannelOperation* res = new TChannelOperation();
		*res = *this;
		return res;
	}


	virtual TChannelOperation& operator =(const TChannelOperation& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TChannelOperation() {
	}


	TChannelOperation(TChannelOperationType _operationType,  std::vector<int32_t> _channel_or_group_id, 
	        std::vector<TChannel> _channels,  std::vector<uint8_t> _data): 
	operationType(_operationType), channel_or_group_id(_channel_or_group_id), channels(_channels), data(_data) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)operationType);
		p.pack(channel_or_group_id);
		p.pack(channels);
		p.pack(data);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddoperationType;
		u.unpack(ddoperationType);
		operationType = (TChannelOperationType)ddoperationType;
		u.unpack(channel_or_group_id);
		u.unpack(channels);
		u.unpack(data);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("operationType", (int32_t)operationType);
		p.pack("channel_or_group_id", channel_or_group_id);
		p.pack("channels", channels);
		p.pack("data", data);
	}



private:
	TChannelOperation& doCopy(const TChannelOperation& other) {
		operationType = other.operationType;
		channel_or_group_id = other.channel_or_group_id;
		channels = other.channels;
		data = other.data;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TChannelOperationResponse: public DUCData {

public:
	TChannelOperationType operationType;

	std::vector<int32_t> channelGroupId;

	std::vector<TChannel> channels;

	std::vector<uint8_t> data;

	ChannelResponseType responseType;

	std::string getTypeName() {
		return "TChannelOperationResponse";
	}


	int32_t getTypeId() {
		return 54;
	}


	static int32_t getStaticId() {
		return 54;
	}


	TChannelOperationResponse(): 
	operationType(ChannelOperation_Open), responseType(ChannelResponse_OK) {
	}


	TChannelOperationResponse(const TChannelOperationResponse& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TChannelOperationResponse* clone() {
		TChannelOperationResponse* res = new TChannelOperationResponse();
		*res = *this;
		return res;
	}


	virtual TChannelOperationResponse& operator =(const TChannelOperationResponse& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TChannelOperationResponse() {
	}


	TChannelOperationResponse(TChannelOperationType _operationType,  std::vector<int32_t> _channelGroupId, 
	        std::vector<TChannel> _channels,  std::vector<uint8_t> _data,  ChannelResponseType _responseType): 
	operationType(_operationType), channelGroupId(_channelGroupId), channels(_channels), data(_data), responseType(_responseType) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)operationType);
		p.pack(channelGroupId);
		p.pack(channels);
		p.pack(data);
		p.pack((int32_t)responseType);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddoperationType;
		u.unpack(ddoperationType);
		operationType = (TChannelOperationType)ddoperationType;
		u.unpack(channelGroupId);
		u.unpack(channels);
		u.unpack(data);
		int32_t ddresponseType;
		u.unpack(ddresponseType);
		responseType = (ChannelResponseType)ddresponseType;
	}


	virtual void streamSub(XPacker& p) {
		p.pack("operationType", (int32_t)operationType);
		p.pack("channelGroupId", channelGroupId);
		p.pack("channels", channels);
		p.pack("data", data);
		p.pack("responseType", (int32_t)responseType);
	}



private:
	TChannelOperationResponse& doCopy(const TChannelOperationResponse& other) {
		operationType = other.operationType;
		channelGroupId = other.channelGroupId;
		channels = other.channels;
		data = other.data;
		responseType = other.responseType;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TColor: public DUCData {

public:
	int32_t r;

	int32_t g;

	int32_t b;

	int32_t a;

	std::string getTypeName() {
		return "TColor";
	}


	int32_t getTypeId() {
		return 2;
	}


	static int32_t getStaticId() {
		return 2;
	}


	TColor(): 
	r(0), g(0), b(0), a(255) {
	}


	TColor(const TColor& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TColor* clone() {
		TColor* res = new TColor();
		*res = *this;
		return res;
	}


	virtual TColor& operator =(const TColor& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TColor() {
	}


	TColor(int32_t _r,  int32_t _g,  int32_t _b,  int32_t _a): 
	r(_r), g(_g), b(_b), a(_a) {
	}


	virtual void packSub(Packer& p) {
		p.pack(r);
		p.pack(g);
		p.pack(b);
		p.pack(a);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(r);
		u.unpack(g);
		u.unpack(b);
		u.unpack(a);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("r", r);
		p.pack("g", g);
		p.pack("b", b);
		p.pack("a", a);
	}



private:
	TColor& doCopy(const TColor& other) {
		r = other.r;
		g = other.g;
		b = other.b;
		a = other.a;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TFont: public DUCData {

public:
	TFontName name;

	int32_t style;

	int32_t size;

	std::string getTypeName() {
		return "TFont";
	}


	int32_t getTypeId() {
		return 10;
	}


	static int32_t getStaticId() {
		return 10;
	}


	TFont(): 
	name(Serif), style(1), size(12) {
	}


	TFont(const TFont& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TFont* clone() {
		TFont* res = new TFont();
		*res = *this;
		return res;
	}


	virtual TFont& operator =(const TFont& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TFont() {
	}


	TFont(TFontName _name,  int32_t _style,  int32_t _size): 
	name(_name), style(_style), size(_size) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)name);
		p.pack(style);
		p.pack(size);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddname;
		u.unpack(ddname);
		name = (TFontName)ddname;
		u.unpack(style);
		u.unpack(size);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("name", (int32_t)name);
		p.pack("style", style);
		p.pack("size", size);
	}



private:
	TFont& doCopy(const TFont& other) {
		name = other.name;
		style = other.style;
		size = other.size;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TImage: public TAbstractVisible {

public:
	std::vector<uint8_t> content;

	ScaleFit xDirection;

	ScaleFit yDirection;

	RelationshipType relationship;

	std::string getTypeName() {
		return "TImage";
	}


	int32_t getTypeId() {
		return 23;
	}


	static int32_t getStaticId() {
		return 23;
	}


	TImage(): 
	relationship(Disrelated) {
	}


	TImage(const TImage& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TImage* clone() {
		TImage* res = new TImage();
		*res = *this;
		return res;
	}


	virtual TImage& operator =(const TImage& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TImage() {
	}


	TImage(std::vector<uint8_t> _content,  ScaleFit _xDirection,  ScaleFit _yDirection, 
	        RelationshipType _relationship): 
	content(_content), xDirection(_xDirection), yDirection(_yDirection), relationship(_relationship) {
	}


	virtual void packSub(Packer& p) {
		p.pack(content);
		p.pack(xDirection);
		p.pack(yDirection);
		p.pack((int32_t)relationship);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(content);
		u.unpack(xDirection);
		u.unpack(yDirection);
		int32_t ddrelationship;
		u.unpack(ddrelationship);
		relationship = (RelationshipType)ddrelationship;
	}


	virtual void streamSub(XPacker& p) {
		p.pack("content", content);
		p.pack("xDirection", xDirection);
		p.pack("yDirection", yDirection);
		p.pack("relationship", (int32_t)relationship);
	}



private:
	TImage& doCopy(const TImage& other) {
		content = other.content;
		xDirection = other.xDirection;
		yDirection = other.yDirection;
		relationship = other.relationship;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TMIME: public DUCData {

public:
	std::string type_subType;

	std::string getTypeName() {
		return "TMIME";
	}


	int32_t getTypeId() {
		return 45;
	}


	static int32_t getStaticId() {
		return 45;
	}


	TMIME() {
	}


	TMIME(const TMIME& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TMIME* clone() {
		TMIME* res = new TMIME();
		*res = *this;
		return res;
	}


	virtual TMIME& operator =(const TMIME& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TMIME() {
	}


	TMIME(std::string _type_subType): 
	type_subType(_type_subType) {
	}


	virtual void packSub(Packer& p) {
		p.pack(type_subType);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(type_subType);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("type_subType", type_subType);
	}



private:
	TMIME& doCopy(const TMIME& other) {
		type_subType = other.type_subType;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TMargin: public DUCData {

public:
	int32_t off_left;

	int32_t off_right;

	int32_t off_up;

	int32_t off_down;

	std::string getTypeName() {
		return "TMargin";
	}


	int32_t getTypeId() {
		return 19;
	}


	static int32_t getStaticId() {
		return 19;
	}


	TMargin(): 
	off_left(0), off_right(0), off_up(0), off_down(0) {
	}


	TMargin(const TMargin& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TMargin* clone() {
		TMargin* res = new TMargin();
		*res = *this;
		return res;
	}


	virtual TMargin& operator =(const TMargin& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TMargin() {
	}


	TMargin(int32_t _off_left,  int32_t _off_right,  int32_t _off_up,  int32_t _off_down): 
	off_left(_off_left), off_right(_off_right), off_up(_off_up), off_down(_off_down) {
	}


	virtual void packSub(Packer& p) {
		p.pack(off_left);
		p.pack(off_right);
		p.pack(off_up);
		p.pack(off_down);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(off_left);
		u.unpack(off_right);
		u.unpack(off_up);
		u.unpack(off_down);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("off_left", off_left);
		p.pack("off_right", off_right);
		p.pack("off_up", off_up);
		p.pack("off_down", off_down);
	}



private:
	TMargin& doCopy(const TMargin& other) {
		off_left = other.off_left;
		off_right = other.off_right;
		off_up = other.off_up;
		off_down = other.off_down;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TNone: public TAbstractVisible {

public:
	std::string getTypeName() {
		return "TNone";
	}


	int32_t getTypeId() {
		return 11;
	}


	static int32_t getStaticId() {
		return 11;
	}


	TNone() {
	}


	TNone(const TNone& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TNone* clone() {
		TNone* res = new TNone();
		*res = *this;
		return res;
	}


	virtual TNone& operator =(const TNone& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TNone() {
	}


	virtual void packSub(Packer& p) {
	}


	virtual void unpackSub(Unpacker& u) {
	}


	virtual void streamSub(XPacker& p) {
	}



private:
	TNone& doCopy(const TNone& other) {
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TPath: public DUCData {

public:
	std::vector<int32_t> node;

	std::string getTypeName() {
		return "TPath";
	}


	int32_t getTypeId() {
		return 8;
	}


	static int32_t getStaticId() {
		return 8;
	}


	TPath() {
	}


	TPath(const TPath& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TPath* clone() {
		TPath* res = new TPath();
		*res = *this;
		return res;
	}


	virtual TPath& operator =(const TPath& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TPath() {
	}


	TPath(std::vector<int32_t> _node): 
	node(_node) {
	}


	virtual void packSub(Packer& p) {
		p.pack(node);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(node);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("node", node);
	}



private:
	TPath& doCopy(const TPath& other) {
		node = other.node;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TPenStroke: public DUCData {

public:
	int32_t width;

	TDashPattern dashPattern;

	std::string getTypeName() {
		return "TPenStroke";
	}


	int32_t getTypeId() {
		return 9;
	}


	static int32_t getStaticId() {
		return 9;
	}


	TPenStroke(): 
	width(0), dashPattern(none) {
	}


	TPenStroke(const TPenStroke& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TPenStroke* clone() {
		TPenStroke* res = new TPenStroke();
		*res = *this;
		return res;
	}


	virtual TPenStroke& operator =(const TPenStroke& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TPenStroke() {
	}


	TPenStroke(int32_t _width,  TDashPattern _dashPattern): 
	width(_width), dashPattern(_dashPattern) {
	}


	virtual void packSub(Packer& p) {
		p.pack(width);
		p.pack((int32_t)dashPattern);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(width);
		int32_t dddashPattern;
		u.unpack(dddashPattern);
		dashPattern = (TDashPattern)dddashPattern;
	}


	virtual void streamSub(XPacker& p) {
		p.pack("width", width);
		p.pack("dashPattern", (int32_t)dashPattern);
	}



private:
	TPenStroke& doCopy(const TPenStroke& other) {
		width = other.width;
		dashPattern = other.dashPattern;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TPoint: public DUCData {

public:
	int32_t x;

	int32_t y;

	std::string getTypeName() {
		return "TPoint";
	}


	int32_t getTypeId() {
		return 3;
	}


	static int32_t getStaticId() {
		return 3;
	}


	TPoint(): 
	x(0), y(0) {
	}


	TPoint(const TPoint& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TPoint* clone() {
		TPoint* res = new TPoint();
		*res = *this;
		return res;
	}


	virtual TPoint& operator =(const TPoint& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TPoint() {
	}


	TPoint(int32_t _x,  int32_t _y): 
	x(_x), y(_y) {
	}


	virtual void packSub(Packer& p) {
		p.pack(x);
		p.pack(y);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(x);
		u.unpack(y);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("x", x);
		p.pack("y", y);
	}



private:
	TPoint& doCopy(const TPoint& other) {
		x = other.x;
		y = other.y;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TPolynomial: public DUCData {

public:
	TPolynomialTypes type;

	std::vector<float> c;

	std::string getTypeName() {
		return "TPolynomial";
	}


	int32_t getTypeId() {
		return 6;
	}


	static int32_t getStaticId() {
		return 6;
	}


	TPolynomial(): 
	type(D1) {
	}


	TPolynomial(const TPolynomial& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TPolynomial* clone() {
		TPolynomial* res = new TPolynomial();
		*res = *this;
		return res;
	}


	virtual TPolynomial& operator =(const TPolynomial& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TPolynomial() {
	}


	TPolynomial(TPolynomialTypes _type,  std::vector<float> _c): 
	type(_type), c(_c) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)type);
		p.pack(c);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddtype;
		u.unpack(ddtype);
		type = (TPolynomialTypes)ddtype;
		u.unpack(c);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("type", (int32_t)type);
		p.pack("c", c);
	}



private:
	TPolynomial& doCopy(const TPolynomial& other) {
		type = other.type;
		c = other.c;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TReference: public TAbstractVisible {

public:
	TPath path;

	std::string getTypeName() {
		return "TReference";
	}


	int32_t getTypeId() {
		return 39;
	}


	static int32_t getStaticId() {
		return 39;
	}


	TReference() {
	}


	TReference(const TReference& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TReference* clone() {
		TReference* res = new TReference();
		*res = *this;
		return res;
	}


	virtual TReference& operator =(const TReference& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TReference() {
	}


	TReference(TPath _path): 
	path(_path) {
	}


	virtual void packSub(Packer& p) {
		p.pack(path);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(path);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("path", path);
	}



private:
	TReference& doCopy(const TReference& other) {
		path = other.path;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TResourceUnit: public DUCData {

public:
	std::string fileName;

	std::vector<uint8_t> data;

	TMIME resourceType;

	std::string getTypeName() {
		return "TResourceUnit";
	}


	int32_t getTypeId() {
		return 44;
	}


	static int32_t getStaticId() {
		return 44;
	}


	TResourceUnit() {
	}


	TResourceUnit(const TResourceUnit& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TResourceUnit* clone() {
		TResourceUnit* res = new TResourceUnit();
		*res = *this;
		return res;
	}


	virtual TResourceUnit& operator =(const TResourceUnit& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TResourceUnit() {
	}


	TResourceUnit(std::string _fileName,  std::vector<uint8_t> _data,  TMIME _resourceType): 
	fileName(_fileName), data(_data), resourceType(_resourceType) {
	}


	virtual void packSub(Packer& p) {
		p.pack(fileName);
		p.pack(data);
		p.pack(resourceType);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(fileName);
		u.unpack(data);
		u.unpack(resourceType);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("fileName", fileName);
		p.pack("data", data);
		p.pack("resourceType", resourceType);
	}



private:
	TResourceUnit& doCopy(const TResourceUnit& other) {
		fileName = other.fileName;
		data = other.data;
		resourceType = other.resourceType;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TResponseClosure: public DUCData {

public:
	std::vector<TResponse> data;

	std::string getTypeName() {
		return "TResponseClosure";
	}


	int32_t getTypeId() {
		return 27;
	}


	static int32_t getStaticId() {
		return 27;
	}


	TResponseClosure() {
	}


	TResponseClosure(const TResponseClosure& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TResponseClosure* clone() {
		TResponseClosure* res = new TResponseClosure();
		*res = *this;
		return res;
	}


	virtual TResponseClosure& operator =(const TResponseClosure& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TResponseClosure() {
	}


	TResponseClosure(std::vector<TResponse> _data): 
	data(_data) {
	}


	virtual void packSub(Packer& p) {
		p.pack(data);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(data);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("data", data);
	}



private:
	TResponseClosure& doCopy(const TResponseClosure& other) {
		data = other.data;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TSelectionCriterion: public DUCData {

public:
	std::string name;

	int32_t importance;

	std::string member;

	std::string getTypeName() {
		return "TSelectionCriterion";
	}


	int32_t getTypeId() {
		return 34;
	}


	static int32_t getStaticId() {
		return 34;
	}


	TSelectionCriterion(): 
	importance(0) {
	}


	TSelectionCriterion(const TSelectionCriterion& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TSelectionCriterion* clone() {
		TSelectionCriterion* res = new TSelectionCriterion();
		*res = *this;
		return res;
	}


	virtual TSelectionCriterion& operator =(const TSelectionCriterion& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TSelectionCriterion() {
	}


	TSelectionCriterion(std::string _name,  int32_t _importance,  std::string _member): 
	name(_name), importance(_importance), member(_member) {
	}


	virtual void packSub(Packer& p) {
		p.pack(name);
		p.pack(importance);
		p.pack(member);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(name);
		u.unpack(importance);
		u.unpack(member);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("name", name);
		p.pack("importance", importance);
		p.pack("member", member);
	}



private:
	TSelectionCriterion& doCopy(const TSelectionCriterion& other) {
		name = other.name;
		importance = other.importance;
		member = other.member;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TSize: public DUCData {

public:
	int32_t width;

	int32_t height;

	std::string getTypeName() {
		return "TSize";
	}


	int32_t getTypeId() {
		return 4;
	}


	static int32_t getStaticId() {
		return 4;
	}


	TSize(): 
	width(10000), height(10000) {
	}


	TSize(const TSize& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TSize* clone() {
		TSize* res = new TSize();
		*res = *this;
		return res;
	}


	virtual TSize& operator =(const TSize& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TSize() {
	}


	TSize(int32_t _width,  int32_t _height): 
	width(_width), height(_height) {
	}


	virtual void packSub(Packer& p) {
		p.pack(width);
		p.pack(height);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(width);
		u.unpack(height);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("width", width);
		p.pack("height", height);
	}



private:
	TSize& doCopy(const TSize& other) {
		width = other.width;
		height = other.height;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TText: public TAbstractVisible {

public:
	std::string text;

	std::vector<GlyphProperties> glyphProperties;

	TColor color;

	TFont font;

	TMargin margin;

	LayoutType layout;

	bool localEditable;

	bool wraparound;

	std::string getTypeName() {
		return "TText";
	}


	int32_t getTypeId() {
		return 21;
	}


	static int32_t getStaticId() {
		return 21;
	}


	TText(): 
	layout(Center), localEditable(false), wraparound(true) {
	}


	TText(const TText& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TText* clone() {
		TText* res = new TText();
		*res = *this;
		return res;
	}


	virtual TText& operator =(const TText& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TText() {
	}


	TText(std::string _text,  std::vector<GlyphProperties> _glyphProperties,  TColor _color, 
	        TFont _font,  TMargin _margin,  LayoutType _layout,  bool _localEditable, 
	        bool _wraparound): 
	text(_text), glyphProperties(_glyphProperties), color(_color), font(_font), margin(_margin), layout(_layout), localEditable(_localEditable), wraparound(_wraparound) {
	}


	virtual void packSub(Packer& p) {
		p.pack(text);
		p.pack(glyphProperties);
		p.pack(color);
		p.pack(font);
		p.pack(margin);
		p.pack((int32_t)layout);
		p.pack(localEditable);
		p.pack(wraparound);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(text);
		u.unpack(glyphProperties);
		u.unpack(color);
		u.unpack(font);
		u.unpack(margin);
		int32_t ddlayout;
		u.unpack(ddlayout);
		layout = (LayoutType)ddlayout;
		u.unpack(localEditable);
		u.unpack(wraparound);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("text", text);
		p.pack("glyphProperties", glyphProperties);
		p.pack("color", color);
		p.pack("font", font);
		p.pack("margin", margin);
		p.pack("layout", (int32_t)layout);
		p.pack("localEditable", localEditable);
		p.pack("wraparound", wraparound);
	}



private:
	TText& doCopy(const TText& other) {
		text = other.text;
		glyphProperties = other.glyphProperties;
		color = other.color;
		font = other.font;
		margin = other.margin;
		layout = other.layout;
		localEditable = other.localEditable;
		wraparound = other.wraparound;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TTransformation: public DUCData {

public:
	int32_t scaleX;

	int32_t scaleY;

	int32_t shearX;

	int32_t shearY;

	int32_t offsetX;

	int32_t offsetY;

	std::string getTypeName() {
		return "TTransformation";
	}


	int32_t getTypeId() {
		return 5;
	}


	static int32_t getStaticId() {
		return 5;
	}


	TTransformation(): 
	scaleX(10000), scaleY(10000), shearX(0), shearY(0), offsetX(0), offsetY(0) {
	}


	TTransformation(const TTransformation& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TTransformation* clone() {
		TTransformation* res = new TTransformation();
		*res = *this;
		return res;
	}


	virtual TTransformation& operator =(const TTransformation& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TTransformation() {
	}


	TTransformation(int32_t _scaleX,  int32_t _scaleY,  int32_t _shearX,  int32_t _shearY, 
	        int32_t _offsetX,  int32_t _offsetY): 
	scaleX(_scaleX), scaleY(_scaleY), shearX(_shearX), shearY(_shearY), offsetX(_offsetX), offsetY(_offsetY) {
	}


	virtual void packSub(Packer& p) {
		p.pack(scaleX);
		p.pack(scaleY);
		p.pack(shearX);
		p.pack(shearY);
		p.pack(offsetX);
		p.pack(offsetY);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(scaleX);
		u.unpack(scaleY);
		u.unpack(shearX);
		u.unpack(shearY);
		u.unpack(offsetX);
		u.unpack(offsetY);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("scaleX", scaleX);
		p.pack("scaleY", scaleY);
		p.pack("shearX", shearX);
		p.pack("shearY", shearY);
		p.pack("offsetX", offsetX);
		p.pack("offsetY", offsetY);
	}



private:
	TTransformation& doCopy(const TTransformation& other) {
		scaleX = other.scaleX;
		scaleY = other.scaleY;
		shearX = other.shearX;
		shearY = other.shearY;
		offsetX = other.offsetX;
		offsetY = other.offsetY;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TUploadResources: public DUCData {

public:
	TPath path;

	std::vector<TResourceUnit> resources;

	std::string getTypeName() {
		return "TUploadResources";
	}


	int32_t getTypeId() {
		return 43;
	}


	static int32_t getStaticId() {
		return 43;
	}


	TUploadResources() {
	}


	TUploadResources(const TUploadResources& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TUploadResources* clone() {
		TUploadResources* res = new TUploadResources();
		*res = *this;
		return res;
	}


	virtual TUploadResources& operator =(const TUploadResources& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TUploadResources() {
	}


	TUploadResources(TPath _path,  std::vector<TResourceUnit> _resources): 
	path(_path), resources(_resources) {
	}


	virtual void packSub(Packer& p) {
		p.pack(path);
		p.pack(resources);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(path);
		u.unpack(resources);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("path", path);
		p.pack("resources", resources);
	}



private:
	TUploadResources& doCopy(const TUploadResources& other) {
		path = other.path;
		resources = other.resources;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class GlyphProperties: public DUCData {

public:
	TColor color;

	TFont font;

	TPoint point;

	std::string getTypeName() {
		return "GlyphProperties";
	}


	int32_t getTypeId() {
		return 20;
	}


	static int32_t getStaticId() {
		return 20;
	}


	GlyphProperties() {
	}


	GlyphProperties(const GlyphProperties& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual GlyphProperties* clone() {
		GlyphProperties* res = new GlyphProperties();
		*res = *this;
		return res;
	}


	virtual GlyphProperties& operator =(const GlyphProperties& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~GlyphProperties() {
	}


	GlyphProperties(TColor _color,  TFont _font,  TPoint _point): 
	color(_color), font(_font), point(_point) {
	}


	virtual void packSub(Packer& p) {
		p.pack(color);
		p.pack(font);
		p.pack(point);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(color);
		u.unpack(font);
		u.unpack(point);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("color", color);
		p.pack("font", font);
		p.pack("point", point);
	}



private:
	GlyphProperties& doCopy(const GlyphProperties& other) {
		color = other.color;
		font = other.font;
		point = other.point;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class T3D: public TAbstractVisible {

public:
	std::string name;

	TImage texture;

	std::vector<uint8_t> textureInfo;

	std::vector<uint8_t> textureModel;

	std::vector<TAnimation> animation;

	std::string getTypeName() {
		return "T3D";
	}


	int32_t getTypeId() {
		return 47;
	}


	static int32_t getStaticId() {
		return 47;
	}


	T3D() {
	}


	T3D(const T3D& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual T3D* clone() {
		T3D* res = new T3D();
		*res = *this;
		return res;
	}


	virtual T3D& operator =(const T3D& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~T3D() {
	}


	T3D(std::string _name,  TImage _texture,  std::vector<uint8_t> _textureInfo,  std::vector<uint8_t> _textureModel, 
	        std::vector<TAnimation> _animation): 
	name(_name), texture(_texture), textureInfo(_textureInfo), textureModel(_textureModel), animation(_animation) {
	}


	virtual void packSub(Packer& p) {
		p.pack(name);
		p.pack(texture);
		p.pack(textureInfo);
		p.pack(textureModel);
		p.pack(animation);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(name);
		u.unpack(texture);
		u.unpack(textureInfo);
		u.unpack(textureModel);
		u.unpack(animation);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("name", name);
		p.pack("texture", texture);
		p.pack("textureInfo", textureInfo);
		p.pack("textureModel", textureModel);
		p.pack("animation", animation);
	}



private:
	T3D& doCopy(const T3D& other) {
		name = other.name;
		texture = other.texture;
		textureInfo = other.textureInfo;
		textureModel = other.textureModel;
		animation = other.animation;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class T3DFog: public DUCData {

public:
	int32_t start;

	int32_t distance;

	TColor color;

	std::string getTypeName() {
		return "T3DFog";
	}


	int32_t getTypeId() {
		return 51;
	}


	static int32_t getStaticId() {
		return 51;
	}


	T3DFog(): 
	start(0), distance(10000) {
	}


	T3DFog(const T3DFog& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual T3DFog* clone() {
		T3DFog* res = new T3DFog();
		*res = *this;
		return res;
	}


	virtual T3DFog& operator =(const T3DFog& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~T3DFog() {
	}


	T3DFog(int32_t _start,  int32_t _distance,  TColor _color): 
	start(_start), distance(_distance), color(_color) {
	}


	virtual void packSub(Packer& p) {
		p.pack(start);
		p.pack(distance);
		p.pack(color);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(start);
		u.unpack(distance);
		u.unpack(color);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("start", start);
		p.pack("distance", distance);
		p.pack("color", color);
	}



private:
	T3DFog& doCopy(const T3DFog& other) {
		start = other.start;
		distance = other.distance;
		color = other.color;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class T3DLight: public DUCData {

public:
	T3DVector position;

	TColor color;

	RotateExtentType rotate;

	std::string getTypeName() {
		return "T3DLight";
	}


	int32_t getTypeId() {
		return 50;
	}


	static int32_t getStaticId() {
		return 50;
	}


	T3DLight(): 
	rotate(ZERO) {
	}


	T3DLight(const T3DLight& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual T3DLight* clone() {
		T3DLight* res = new T3DLight();
		*res = *this;
		return res;
	}


	virtual T3DLight& operator =(const T3DLight& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~T3DLight() {
	}


	T3DLight(T3DVector _position,  TColor _color,  RotateExtentType _rotate): 
	position(_position), color(_color), rotate(_rotate) {
	}


	virtual void packSub(Packer& p) {
		p.pack(position);
		p.pack(color);
		p.pack((int32_t)rotate);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(position);
		u.unpack(color);
		int32_t ddrotate;
		u.unpack(ddrotate);
		rotate = (RotateExtentType)ddrotate;
	}


	virtual void streamSub(XPacker& p) {
		p.pack("position", position);
		p.pack("color", color);
		p.pack("rotate", (int32_t)rotate);
	}



private:
	T3DLight& doCopy(const T3DLight& other) {
		position = other.position;
		color = other.color;
		rotate = other.rotate;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class T3DPlacement: public DUCData {

public:
	T3DVector position;

	RotateExtentType rotate;

	int32_t scale;

	T3D data;

	std::string getTypeName() {
		return "T3DPlacement";
	}


	int32_t getTypeId() {
		return 48;
	}


	static int32_t getStaticId() {
		return 48;
	}


	T3DPlacement(): 
	rotate(ZERO), scale(0) {
	}


	T3DPlacement(const T3DPlacement& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual T3DPlacement* clone() {
		T3DPlacement* res = new T3DPlacement();
		*res = *this;
		return res;
	}


	virtual T3DPlacement& operator =(const T3DPlacement& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~T3DPlacement() {
	}


	T3DPlacement(T3DVector _position,  RotateExtentType _rotate,  int32_t _scale,  T3D _data): 
	position(_position), rotate(_rotate), scale(_scale), data(_data) {
	}


	virtual void packSub(Packer& p) {
		p.pack(position);
		p.pack((int32_t)rotate);
		p.pack(scale);
		p.pack(data);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(position);
		int32_t ddrotate;
		u.unpack(ddrotate);
		rotate = (RotateExtentType)ddrotate;
		u.unpack(scale);
		u.unpack(data);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("position", position);
		p.pack("rotate", (int32_t)rotate);
		p.pack("scale", scale);
		p.pack("data", data);
	}



private:
	T3DPlacement& doCopy(const T3DPlacement& other) {
		position = other.position;
		rotate = other.rotate;
		scale = other.scale;
		data = other.data;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class T3DWorld: public TAbstractVisible {

public:
	std::vector<T3DLight> lights;

	std::vector<T3DPlacement> objects;

	std::vector<T3DFog> fogs;

	std::string getTypeName() {
		return "T3DWorld";
	}


	int32_t getTypeId() {
		return 49;
	}


	static int32_t getStaticId() {
		return 49;
	}


	T3DWorld() {
	}


	T3DWorld(const T3DWorld& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual T3DWorld* clone() {
		T3DWorld* res = new T3DWorld();
		*res = *this;
		return res;
	}


	virtual T3DWorld& operator =(const T3DWorld& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~T3DWorld() {
	}


	T3DWorld(std::vector<T3DLight> _lights,  std::vector<T3DPlacement> _objects,  std::vector<T3DFog> _fogs): 
	lights(_lights), objects(_objects), fogs(_fogs) {
	}


	virtual void packSub(Packer& p) {
		p.pack(lights);
		p.pack(objects);
		p.pack(fogs);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(lights);
		u.unpack(objects);
		u.unpack(fogs);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("lights", lights);
		p.pack("objects", objects);
		p.pack("fogs", fogs);
	}



private:
	T3DWorld& doCopy(const T3DWorld& other) {
		lights = other.lights;
		objects = other.objects;
		fogs = other.fogs;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TAttachNode: public DUCData {

public:
	TPath parent;

	int32_t id;

	int32_t order;

	TPath source;

	std::string getTypeName() {
		return "TAttachNode";
	}


	int32_t getTypeId() {
		return 29;
	}


	static int32_t getStaticId() {
		return 29;
	}


	TAttachNode(): 
	id(0), order(0) {
	}


	TAttachNode(const TAttachNode& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TAttachNode* clone() {
		TAttachNode* res = new TAttachNode();
		*res = *this;
		return res;
	}


	virtual TAttachNode& operator =(const TAttachNode& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TAttachNode() {
	}


	TAttachNode(TPath _parent,  int32_t _id,  int32_t _order,  TPath _source): 
	parent(_parent), id(_id), order(_order), source(_source) {
	}


	virtual void packSub(Packer& p) {
		p.pack(parent);
		p.pack(id);
		p.pack(order);
		p.pack(source);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(parent);
		u.unpack(id);
		u.unpack(order);
		u.unpack(source);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("parent", parent);
		p.pack("id", id);
		p.pack("order", order);
		p.pack("source", source);
	}



private:
	TAttachNode& doCopy(const TAttachNode& other) {
		parent = other.parent;
		id = other.id;
		order = other.order;
		source = other.source;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TChannel: public DUCData {

public:
	TMIME type;

	int32_t id;

	std::string name;

	std::string url;

	int32_t port;

	TPath path;

	std::string getTypeName() {
		return "TChannel";
	}


	int32_t getTypeId() {
		return 52;
	}


	static int32_t getStaticId() {
		return 52;
	}


	TChannel(): 
	id(-1), port(-1) {
	}


	TChannel(const TChannel& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TChannel* clone() {
		TChannel* res = new TChannel();
		*res = *this;
		return res;
	}


	virtual TChannel& operator =(const TChannel& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TChannel() {
	}


	TChannel(TMIME _type,  int32_t _id,  std::string _name,  std::string _url,  int32_t _port, 
	        TPath _path): 
	type(_type), id(_id), name(_name), url(_url), port(_port), path(_path) {
	}


	virtual void packSub(Packer& p) {
		p.pack(type);
		p.pack(id);
		p.pack(name);
		p.pack(url);
		p.pack(port);
		p.pack(path);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(type);
		u.unpack(id);
		u.unpack(name);
		u.unpack(url);
		u.unpack(port);
		u.unpack(path);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("type", type);
		p.pack("id", id);
		p.pack("name", name);
		p.pack("url", url);
		p.pack("port", port);
		p.pack("path", path);
	}



private:
	TChannel& doCopy(const TChannel& other) {
		type = other.type;
		id = other.id;
		name = other.name;
		url = other.url;
		port = other.port;
		path = other.path;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TColorGradient: public DUCData {

public:
	TPoint p1;

	TColor c1;

	TPoint p2;

	TColor c2;

	TPolynomial distribution;

	std::string getTypeName() {
		return "TColorGradient";
	}


	int32_t getTypeId() {
		return 7;
	}


	static int32_t getStaticId() {
		return 7;
	}


	TColorGradient() {
	}


	TColorGradient(const TColorGradient& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TColorGradient* clone() {
		TColorGradient* res = new TColorGradient();
		*res = *this;
		return res;
	}


	virtual TColorGradient& operator =(const TColorGradient& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TColorGradient() {
	}


	TColorGradient(TPoint _p1,  TColor _c1,  TPoint _p2,  TColor _c2,  TPolynomial _distribution): 
	p1(_p1), c1(_c1), p2(_p2), c2(_c2), distribution(_distribution) {
	}


	virtual void packSub(Packer& p) {
		p.pack(p1);
		p.pack(c1);
		p.pack(p2);
		p.pack(c2);
		p.pack(distribution);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(p1);
		u.unpack(c1);
		u.unpack(p2);
		u.unpack(c2);
		u.unpack(distribution);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("p1", p1);
		p.pack("c1", c1);
		p.pack("p2", p2);
		p.pack("c2", c2);
		p.pack("distribution", distribution);
	}



private:
	TColorGradient& doCopy(const TColorGradient& other) {
		p1 = other.p1;
		c1 = other.c1;
		p2 = other.p2;
		c2 = other.c2;
		distribution = other.distribution;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TCursor: public DUCData {

public:
	CursorType cursorType;

	TImage image;

	TPoint hotspot;

	TSize size;

	std::string getTypeName() {
		return "TCursor";
	}


	int32_t getTypeId() {
		return 36;
	}


	static int32_t getStaticId() {
		return 36;
	}


	TCursor(): 
	cursorType(Default_Cursor) {
	}


	TCursor(const TCursor& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TCursor* clone() {
		TCursor* res = new TCursor();
		*res = *this;
		return res;
	}


	virtual TCursor& operator =(const TCursor& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TCursor() {
	}


	TCursor(CursorType _cursorType,  TImage _image,  TPoint _hotspot,  TSize _size): 
	cursorType(_cursorType), image(_image), hotspot(_hotspot), size(_size) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)cursorType);
		p.pack(image);
		p.pack(hotspot);
		p.pack(size);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddcursorType;
		u.unpack(ddcursorType);
		cursorType = (CursorType)ddcursorType;
		u.unpack(image);
		u.unpack(hotspot);
		u.unpack(size);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("cursorType", (int32_t)cursorType);
		p.pack("image", image);
		p.pack("hotspot", hotspot);
		p.pack("size", size);
	}



private:
	TCursor& doCopy(const TCursor& other) {
		cursorType = other.cursorType;
		image = other.image;
		hotspot = other.hotspot;
		size = other.size;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TCurve: public TAbstractVisible {

public:
	std::vector<TPoint> points;

	std::vector<bool> pointsType;

	std::vector<TCurve> curves;

	TCurveType curveType;

	TPenStroke stroke;

	TColor color;

	bool closed;

	std::string getTypeName() {
		return "TCurve";
	}


	int32_t getTypeId() {
		return 15;
	}


	static int32_t getStaticId() {
		return 15;
	}


	TCurve(): 
	curveType(Curve_QUAD), closed(false) {
	}


	TCurve(const TCurve& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TCurve* clone() {
		TCurve* res = new TCurve();
		*res = *this;
		return res;
	}


	virtual TCurve& operator =(const TCurve& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TCurve() {
	}


	TCurve(std::vector<TPoint> _points,  std::vector<bool> _pointsType,  std::vector<TCurve> _curves, 
	        TCurveType _curveType,  TPenStroke _stroke,  TColor _color,  bool _closed): 
	points(_points), pointsType(_pointsType), curves(_curves), curveType(_curveType), stroke(_stroke), color(_color), closed(_closed) {
	}


	virtual void packSub(Packer& p) {
		p.pack(points);
		p.pack(pointsType);
		p.pack(curves);
		p.pack((int32_t)curveType);
		p.pack(stroke);
		p.pack(color);
		p.pack(closed);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(points);
		u.unpack(pointsType);
		u.unpack(curves);
		int32_t ddcurveType;
		u.unpack(ddcurveType);
		curveType = (TCurveType)ddcurveType;
		u.unpack(stroke);
		u.unpack(color);
		u.unpack(closed);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("points", points);
		p.pack("pointsType", pointsType);
		p.pack("curves", curves);
		p.pack("curveType", (int32_t)curveType);
		p.pack("stroke", stroke);
		p.pack("color", color);
		p.pack("closed", closed);
	}



private:
	TCurve& doCopy(const TCurve& other) {
		points = other.points;
		pointsType = other.pointsType;
		curves = other.curves;
		curveType = other.curveType;
		stroke = other.stroke;
		color = other.color;
		closed = other.closed;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TDeleteNode: public DUCData {

public:
	TPath path;

	std::string getTypeName() {
		return "TDeleteNode";
	}


	int32_t getTypeId() {
		return 30;
	}


	static int32_t getStaticId() {
		return 30;
	}


	TDeleteNode() {
	}


	TDeleteNode(const TDeleteNode& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TDeleteNode* clone() {
		TDeleteNode* res = new TDeleteNode();
		*res = *this;
		return res;
	}


	virtual TDeleteNode& operator =(const TDeleteNode& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TDeleteNode() {
	}


	TDeleteNode(TPath _path): 
	path(_path) {
	}


	virtual void packSub(Packer& p) {
		p.pack(path);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(path);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("path", path);
	}



private:
	TDeleteNode& doCopy(const TDeleteNode& other) {
		path = other.path;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TEllipse: public TAbstractVisible {

public:
	TPenStroke stroke;

	TColor edgeColor;

	TColor background;

	TColorGradient colorPaint;

	bool fill;

	std::string getTypeName() {
		return "TEllipse";
	}


	int32_t getTypeId() {
		return 13;
	}


	static int32_t getStaticId() {
		return 13;
	}


	TEllipse(): 
	fill(true) {
	}


	TEllipse(const TEllipse& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TEllipse* clone() {
		TEllipse* res = new TEllipse();
		*res = *this;
		return res;
	}


	virtual TEllipse& operator =(const TEllipse& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TEllipse() {
	}


	TEllipse(TPenStroke _stroke,  TColor _edgeColor,  TColor _background,  TColorGradient _colorPaint, 
	        bool _fill): 
	stroke(_stroke), edgeColor(_edgeColor), background(_background), colorPaint(_colorPaint), fill(_fill) {
	}


	virtual void packSub(Packer& p) {
		p.pack(stroke);
		p.pack(edgeColor);
		p.pack(background);
		p.pack(colorPaint);
		p.pack(fill);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(stroke);
		u.unpack(edgeColor);
		u.unpack(background);
		u.unpack(colorPaint);
		u.unpack(fill);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("stroke", stroke);
		p.pack("edgeColor", edgeColor);
		p.pack("background", background);
		p.pack("colorPaint", colorPaint);
		p.pack("fill", fill);
	}



private:
	TEllipse& doCopy(const TEllipse& other) {
		stroke = other.stroke;
		edgeColor = other.edgeColor;
		background = other.background;
		colorPaint = other.colorPaint;
		fill = other.fill;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TGeneralCurve: public TAbstractVisible {

public:
	std::vector<TPoint> points;

	std::vector<bool> pointsType;

	std::vector<TGeneralCurve> curves;

	TCurveType curveType;

	TPenStroke stroke;

	TColor color;

	TColor fillColor;

	bool fill;

	bool closed;

	std::string getTypeName() {
		return "TGeneralCurve";
	}


	int32_t getTypeId() {
		return 16;
	}


	static int32_t getStaticId() {
		return 16;
	}


	TGeneralCurve(): 
	curveType(Curve_QUAD), fill(false), closed(false) {
	}


	TGeneralCurve(const TGeneralCurve& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TGeneralCurve* clone() {
		TGeneralCurve* res = new TGeneralCurve();
		*res = *this;
		return res;
	}


	virtual TGeneralCurve& operator =(const TGeneralCurve& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TGeneralCurve() {
	}


	TGeneralCurve(std::vector<TPoint> _points,  std::vector<bool> _pointsType,  std::vector<TGeneralCurve> _curves, 
	        TCurveType _curveType,  TPenStroke _stroke,  TColor _color,  TColor _fillColor, 
	        bool _fill,  bool _closed): 
	points(_points), pointsType(_pointsType), curves(_curves), curveType(_curveType), stroke(_stroke), color(_color), fillColor(_fillColor), fill(_fill), closed(_closed) {
	}


	virtual void packSub(Packer& p) {
		p.pack(points);
		p.pack(pointsType);
		p.pack(curves);
		p.pack((int32_t)curveType);
		p.pack(stroke);
		p.pack(color);
		p.pack(fillColor);
		p.pack(fill);
		p.pack(closed);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(points);
		u.unpack(pointsType);
		u.unpack(curves);
		int32_t ddcurveType;
		u.unpack(ddcurveType);
		curveType = (TCurveType)ddcurveType;
		u.unpack(stroke);
		u.unpack(color);
		u.unpack(fillColor);
		u.unpack(fill);
		u.unpack(closed);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("points", points);
		p.pack("pointsType", pointsType);
		p.pack("curves", curves);
		p.pack("curveType", (int32_t)curveType);
		p.pack("stroke", stroke);
		p.pack("color", color);
		p.pack("fillColor", fillColor);
		p.pack("fill", fill);
		p.pack("closed", closed);
	}



private:
	TGeneralCurve& doCopy(const TGeneralCurve& other) {
		points = other.points;
		pointsType = other.pointsType;
		curves = other.curves;
		curveType = other.curveType;
		stroke = other.stroke;
		color = other.color;
		fillColor = other.fillColor;
		fill = other.fill;
		closed = other.closed;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TGesture: public DUCData {

public:
	TGestureType type;

	std::vector<TModifier> modifier;

	std::string text;

	std::vector<TPath> path;

	std::vector<TPoint> positions;

	TPoint positionOnRoot;

	TSize offSet;

	std::vector<TResourceUnit> resources;

	int32_t scale;

	std::vector<TSize> visualSizes;

	int32_t viewVersion;

	std::string getTypeName() {
		return "TGesture";
	}


	int32_t getTypeId() {
		return 24;
	}


	static int32_t getStaticId() {
		return 24;
	}


	TGesture(): 
	type(Start), modifier(Function), scale(0), viewVersion(-1) {
	}


	TGesture(const TGesture& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TGesture* clone() {
		TGesture* res = new TGesture();
		*res = *this;
		return res;
	}


	virtual TGesture& operator =(const TGesture& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TGesture() {
	}


	TGesture(TGestureType _type,  std::vector<TModifier> _modifier,  std::string _text, 
	        std::vector<TPath> _path,  std::vector<TPoint> _positions,  TPoint _positionOnRoot, 
	        TSize _offSet,  std::vector<TResourceUnit> _resources,  int32_t _scale, 
	        std::vector<TSize> _visualSizes,  int32_t _viewVersion): 
	type(_type), modifier(_modifier), text(_text), path(_path), positions(_positions), positionOnRoot(_positionOnRoot), offSet(_offSet), resources(_resources), scale(_scale), visualSizes(_visualSizes), viewVersion(_viewVersion) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)type);
		std::vector<int32_t> ddmodifier;
		for(unsigned int i = 0; i < modifier.size(); ++i) ddmodifier.push_back((int32_t)modifier[i]);
		p.pack(ddmodifier);
		p.pack(text);
		p.pack(path);
		p.pack(positions);
		p.pack(positionOnRoot);
		p.pack(offSet);
		p.pack(resources);
		p.pack(scale);
		p.pack(visualSizes);
		p.pack(viewVersion);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddtype;
		u.unpack(ddtype);
		type = (TGestureType)ddtype;
		std::vector<int32_t> ddmodifier;
		u.unpack(ddmodifier);
		for(unsigned int i = 0; i < ddmodifier.size(); ++i) modifier.push_back((TModifier)ddmodifier[i]);
		u.unpack(text);
		u.unpack(path);
		u.unpack(positions);
		u.unpack(positionOnRoot);
		u.unpack(offSet);
		u.unpack(resources);
		u.unpack(scale);
		u.unpack(visualSizes);
		u.unpack(viewVersion);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("type", (int32_t)type);
		std::vector<int32_t> ddmodifier;
		for(unsigned int i = 0; i < modifier.size(); ++i) ddmodifier.push_back((int32_t)modifier[i]);
		p.pack("modifier", ddmodifier);
		p.pack("text", text);
		p.pack("path", path);
		p.pack("positions", positions);
		p.pack("positionOnRoot", positionOnRoot);
		p.pack("offSet", offSet);
		p.pack("resources", resources);
		p.pack("scale", scale);
		p.pack("visualSizes", visualSizes);
		p.pack("viewVersion", viewVersion);
	}



private:
	TGesture& doCopy(const TGesture& other) {
		type = other.type;
		modifier = other.modifier;
		text = other.text;
		path = other.path;
		positions = other.positions;
		positionOnRoot = other.positionOnRoot;
		offSet = other.offSet;
		resources = other.resources;
		scale = other.scale;
		visualSizes = other.visualSizes;
		viewVersion = other.viewVersion;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TGetResourcesFromUsr: public DUCData {

public:
	TPath path;

	TMIME resourceType;

	bool multiSelectionEnabled;

	std::string getTypeName() {
		return "TGetResourcesFromUsr";
	}


	int32_t getTypeId() {
		return 42;
	}


	static int32_t getStaticId() {
		return 42;
	}


	TGetResourcesFromUsr(): 
	multiSelectionEnabled(false) {
	}


	TGetResourcesFromUsr(const TGetResourcesFromUsr& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TGetResourcesFromUsr* clone() {
		TGetResourcesFromUsr* res = new TGetResourcesFromUsr();
		*res = *this;
		return res;
	}


	virtual TGetResourcesFromUsr& operator =(const TGetResourcesFromUsr& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TGetResourcesFromUsr() {
	}


	TGetResourcesFromUsr(TPath _path,  TMIME _resourceType,  bool _multiSelectionEnabled): 
	path(_path), resourceType(_resourceType), multiSelectionEnabled(_multiSelectionEnabled) {
	}


	virtual void packSub(Packer& p) {
		p.pack(path);
		p.pack(resourceType);
		p.pack(multiSelectionEnabled);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(path);
		u.unpack(resourceType);
		u.unpack(multiSelectionEnabled);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("path", path);
		p.pack("resourceType", resourceType);
		p.pack("multiSelectionEnabled", multiSelectionEnabled);
	}



private:
	TGetResourcesFromUsr& doCopy(const TGetResourcesFromUsr& other) {
		path = other.path;
		resourceType = other.resourceType;
		multiSelectionEnabled = other.multiSelectionEnabled;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TInformServer: public DUCData {

public:
	TGesture gesture;

	std::string getTypeName() {
		return "TInformServer";
	}


	int32_t getTypeId() {
		return 25;
	}


	static int32_t getStaticId() {
		return 25;
	}


	TInformServer() {
	}


	TInformServer(const TInformServer& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TInformServer* clone() {
		TInformServer* res = new TInformServer();
		*res = *this;
		return res;
	}


	virtual TInformServer& operator =(const TInformServer& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TInformServer() {
	}


	TInformServer(TGesture _gesture): 
	gesture(_gesture) {
	}


	virtual void packSub(Packer& p) {
		p.pack(gesture);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(gesture);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("gesture", gesture);
	}



private:
	TInformServer& doCopy(const TInformServer& other) {
		gesture = other.gesture;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TLine: public TAbstractVisible {

public:
	TPenStroke stroke;

	TColor color;

	std::string getTypeName() {
		return "TLine";
	}


	int32_t getTypeId() {
		return 12;
	}


	static int32_t getStaticId() {
		return 12;
	}


	TLine() {
	}


	TLine(const TLine& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TLine* clone() {
		TLine* res = new TLine();
		*res = *this;
		return res;
	}


	virtual TLine& operator =(const TLine& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TLine() {
	}


	TLine(TPenStroke _stroke,  TColor _color): 
	stroke(_stroke), color(_color) {
	}


	virtual void packSub(Packer& p) {
		p.pack(stroke);
		p.pack(color);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(stroke);
		u.unpack(color);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("stroke", stroke);
		p.pack("color", color);
	}



private:
	TLine& doCopy(const TLine& other) {
		stroke = other.stroke;
		color = other.color;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TPlacement: public DUCData {

public:
	TPath path;

	int32_t order;

	bool display;

	TPoint position;

	TPostionType referencePoint;

	std::vector<int32_t> referencePointDerivation;

	TSize size;

	TValueType widthValueType;

	TValueType heightValueType;

	TTransformation transformation;

	std::vector<int32_t> relativeValueDerivation;

	std::vector<TSelectionCriterion> matchedCriterion;

	TAbstractVisible* data;

	TSize innerOffset;

	int32_t scale;

	std::string getTypeName() {
		return "TPlacement";
	}


	int32_t getTypeId() {
		return 35;
	}


	static int32_t getStaticId() {
		return 35;
	}


	TPlacement(): 
	order(0), display(true), referencePoint(TPostionType_Left_Up_In), widthValueType(ValueType_Fixed), heightValueType(ValueType_Fixed), data(0), scale(0) {
	}


	TPlacement(const TPlacement& other): 
	DUCData(other) {
		data = 0;
		doCopy(other);
	}


	virtual TPlacement* clone() {
		TPlacement* res = new TPlacement();
		*res = *this;
		return res;
	}


	virtual TPlacement& operator =(const TPlacement& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TPlacement() {
		if(data != 0) delete data;
	}


	TPlacement(TPath _path,  int32_t _order,  bool _display,  TPoint _position,  TPostionType _referencePoint, 
	        std::vector<int32_t> _referencePointDerivation,  TSize _size,  TValueType _widthValueType, 
	        TValueType _heightValueType,  TTransformation _transformation,  std::vector<int32_t> _relativeValueDerivation, 
	        std::vector<TSelectionCriterion> _matchedCriterion,  TAbstractVisible* _data, 
	        TSize _innerOffset,  int32_t _scale): 
	path(_path), order(_order), display(_display), position(_position), referencePoint(_referencePoint), referencePointDerivation(_referencePointDerivation), size(_size), widthValueType(_widthValueType), heightValueType(_heightValueType), transformation(_transformation), relativeValueDerivation(_relativeValueDerivation), matchedCriterion(_matchedCriterion), data(_data), innerOffset(_innerOffset), scale(_scale) {
	}


	virtual void packSub(Packer& p) {
		p.pack(path);
		p.pack(order);
		p.pack(display);
		p.pack(position);
		p.pack((int32_t)referencePoint);
		p.pack(referencePointDerivation);
		p.pack(size);
		p.pack((int32_t)widthValueType);
		p.pack((int32_t)heightValueType);
		p.pack(transformation);
		p.pack(relativeValueDerivation);
		p.pack(matchedCriterion);
		p.pack(data);
		p.pack(innerOffset);
		p.pack(scale);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(path);
		u.unpack(order);
		u.unpack(display);
		u.unpack(position);
		int32_t ddreferencePoint;
		u.unpack(ddreferencePoint);
		referencePoint = (TPostionType)ddreferencePoint;
		u.unpack(referencePointDerivation);
		u.unpack(size);
		int32_t ddwidthValueType;
		u.unpack(ddwidthValueType);
		widthValueType = (TValueType)ddwidthValueType;
		int32_t ddheightValueType;
		u.unpack(ddheightValueType);
		heightValueType = (TValueType)ddheightValueType;
		u.unpack(transformation);
		u.unpack(relativeValueDerivation);
		u.unpack(matchedCriterion);
		u.unpack(data);
		u.unpack(innerOffset);
		u.unpack(scale);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("path", path);
		p.pack("order", order);
		p.pack("display", display);
		p.pack("position", position);
		p.pack("referencePoint", (int32_t)referencePoint);
		p.pack("referencePointDerivation", referencePointDerivation);
		p.pack("size", size);
		p.pack("widthValueType", (int32_t)widthValueType);
		p.pack("heightValueType", (int32_t)heightValueType);
		p.pack("transformation", transformation);
		p.pack("relativeValueDerivation", relativeValueDerivation);
		p.pack("matchedCriterion", matchedCriterion);
		p.pack("data", data);
		p.pack("innerOffset", innerOffset);
		p.pack("scale", scale);
	}



private:
	TPlacement& doCopy(const TPlacement& other) {
		path = other.path;
		order = other.order;
		display = other.display;
		position = other.position;
		referencePoint = other.referencePoint;
		referencePointDerivation = other.referencePointDerivation;
		size = other.size;
		widthValueType = other.widthValueType;
		heightValueType = other.heightValueType;
		transformation = other.transformation;
		relativeValueDerivation = other.relativeValueDerivation;
		matchedCriterion = other.matchedCriterion;
		if(data != 0) delete data;
		if(other.data!= 0) data = other.data->clone();
		else data = 0;
		innerOffset = other.innerOffset;
		scale = other.scale;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TRectangle: public TAbstractVisible {

public:
	TPenStroke stroke;

	TColor edgeColor;

	TColor background;

	TColorGradient colorPaint;

	int32_t roundRadius;

	bool fill;

	std::string getTypeName() {
		return "TRectangle";
	}


	int32_t getTypeId() {
		return 14;
	}


	static int32_t getStaticId() {
		return 14;
	}


	TRectangle(): 
	roundRadius(0), fill(true) {
	}


	TRectangle(const TRectangle& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TRectangle* clone() {
		TRectangle* res = new TRectangle();
		*res = *this;
		return res;
	}


	virtual TRectangle& operator =(const TRectangle& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TRectangle() {
	}


	TRectangle(TPenStroke _stroke,  TColor _edgeColor,  TColor _background,  TColorGradient _colorPaint, 
	        int32_t _roundRadius,  bool _fill): 
	stroke(_stroke), edgeColor(_edgeColor), background(_background), colorPaint(_colorPaint), roundRadius(_roundRadius), fill(_fill) {
	}


	virtual void packSub(Packer& p) {
		p.pack(stroke);
		p.pack(edgeColor);
		p.pack(background);
		p.pack(colorPaint);
		p.pack(roundRadius);
		p.pack(fill);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(stroke);
		u.unpack(edgeColor);
		u.unpack(background);
		u.unpack(colorPaint);
		u.unpack(roundRadius);
		u.unpack(fill);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("stroke", stroke);
		p.pack("edgeColor", edgeColor);
		p.pack("background", background);
		p.pack("colorPaint", colorPaint);
		p.pack("roundRadius", roundRadius);
		p.pack("fill", fill);
	}



private:
	TRectangle& doCopy(const TRectangle& other) {
		stroke = other.stroke;
		edgeColor = other.edgeColor;
		background = other.background;
		colorPaint = other.colorPaint;
		roundRadius = other.roundRadius;
		fill = other.fill;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TReplaceNode: public DUCData {

public:
	TPlacement data;

	std::string getTypeName() {
		return "TReplaceNode";
	}


	int32_t getTypeId() {
		return 31;
	}


	static int32_t getStaticId() {
		return 31;
	}


	TReplaceNode() {
	}


	TReplaceNode(const TReplaceNode& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TReplaceNode* clone() {
		TReplaceNode* res = new TReplaceNode();
		*res = *this;
		return res;
	}


	virtual TReplaceNode& operator =(const TReplaceNode& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TReplaceNode() {
	}


	TReplaceNode(TPlacement _data): 
	data(_data) {
	}


	virtual void packSub(Packer& p) {
		p.pack(data);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(data);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("data", data);
	}



private:
	TReplaceNode& doCopy(const TReplaceNode& other) {
		data = other.data;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TResponse: public DUCData {

public:
	TResponseType responseType;

	TPlacement data;

	std::string getTypeName() {
		return "TResponse";
	}


	int32_t getTypeId() {
		return 26;
	}


	static int32_t getStaticId() {
		return 26;
	}


	TResponse(): 
	responseType(Response_Add) {
	}


	TResponse(const TResponse& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TResponse* clone() {
		TResponse* res = new TResponse();
		*res = *this;
		return res;
	}


	virtual TResponse& operator =(const TResponse& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TResponse() {
	}


	TResponse(TResponseType _responseType,  TPlacement _data): 
	responseType(_responseType), data(_data) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)responseType);
		p.pack(data);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddresponseType;
		u.unpack(ddresponseType);
		responseType = (TResponseType)ddresponseType;
		u.unpack(data);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("responseType", (int32_t)responseType);
		p.pack("data", data);
	}



private:
	TResponse& doCopy(const TResponse& other) {
		responseType = other.responseType;
		data = other.data;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TUpdateNode: public DUCData {

public:
	TPlacement data;

	std::string getTypeName() {
		return "TUpdateNode";
	}


	int32_t getTypeId() {
		return 32;
	}


	static int32_t getStaticId() {
		return 32;
	}


	TUpdateNode() {
	}


	TUpdateNode(const TUpdateNode& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TUpdateNode* clone() {
		TUpdateNode* res = new TUpdateNode();
		*res = *this;
		return res;
	}


	virtual TUpdateNode& operator =(const TUpdateNode& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TUpdateNode() {
	}


	TUpdateNode(TPlacement _data): 
	data(_data) {
	}


	virtual void packSub(Packer& p) {
		p.pack(data);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(data);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("data", data);
	}



private:
	TUpdateNode& doCopy(const TUpdateNode& other) {
		data = other.data;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TAddNode: public DUCData {

public:
	TPlacement data;

	std::string getTypeName() {
		return "TAddNode";
	}


	int32_t getTypeId() {
		return 28;
	}


	static int32_t getStaticId() {
		return 28;
	}


	TAddNode() {
	}


	TAddNode(const TAddNode& other): 
	DUCData(other) {
		doCopy(other);
	}


	virtual TAddNode* clone() {
		TAddNode* res = new TAddNode();
		*res = *this;
		return res;
	}


	virtual TAddNode& operator =(const TAddNode& other) {
		if(this == &other) return *this;
		DUCData::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TAddNode() {
	}


	TAddNode(TPlacement _data): 
	data(_data) {
	}


	virtual void packSub(Packer& p) {
		p.pack(data);
	}


	virtual void unpackSub(Unpacker& u) {
		u.unpack(data);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("data", data);
	}



private:
	TAddNode& doCopy(const TAddNode& other) {
		data = other.data;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TArc: public TAbstractVisible {

public:
	TArcClosedType closedType;

	int32_t start;

	int32_t extent;

	TColor edgeColor;

	TColor background;

	TColorGradient colorPaint;

	bool fill;

	std::string getTypeName() {
		return "TArc";
	}


	int32_t getTypeId() {
		return 18;
	}


	static int32_t getStaticId() {
		return 18;
	}


	TArc(): 
	closedType(ArcClosedType_CHORD), start(0), extent(0), fill(true) {
	}


	TArc(const TArc& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TArc* clone() {
		TArc* res = new TArc();
		*res = *this;
		return res;
	}


	virtual TArc& operator =(const TArc& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TArc() {
	}


	TArc(TArcClosedType _closedType,  int32_t _start,  int32_t _extent,  TColor _edgeColor, 
	        TColor _background,  TColorGradient _colorPaint,  bool _fill): 
	closedType(_closedType), start(_start), extent(_extent), edgeColor(_edgeColor), background(_background), colorPaint(_colorPaint), fill(_fill) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)closedType);
		p.pack(start);
		p.pack(extent);
		p.pack(edgeColor);
		p.pack(background);
		p.pack(colorPaint);
		p.pack(fill);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddclosedType;
		u.unpack(ddclosedType);
		closedType = (TArcClosedType)ddclosedType;
		u.unpack(start);
		u.unpack(extent);
		u.unpack(edgeColor);
		u.unpack(background);
		u.unpack(colorPaint);
		u.unpack(fill);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("closedType", (int32_t)closedType);
		p.pack("start", start);
		p.pack("extent", extent);
		p.pack("edgeColor", edgeColor);
		p.pack("background", background);
		p.pack("colorPaint", colorPaint);
		p.pack("fill", fill);
	}



private:
	TArc& doCopy(const TArc& other) {
		closedType = other.closedType;
		start = other.start;
		extent = other.extent;
		edgeColor = other.edgeColor;
		background = other.background;
		colorPaint = other.colorPaint;
		fill = other.fill;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TArea: public TAbstractVisible {

public:
	TShapeType shapeType;

	std::vector<TPoint> points;

	std::vector<TArea> areaSet;

	CAGType cagType;

	TColor background;

	TColorGradient colorPaint;

	std::string getTypeName() {
		return "TArea";
	}


	int32_t getTypeId() {
		return 17;
	}


	static int32_t getStaticId() {
		return 17;
	}


	TArea(): 
	shapeType(Shape_GeneralCurve), cagType(CAGType_Add) {
	}


	TArea(const TArea& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TArea* clone() {
		TArea* res = new TArea();
		*res = *this;
		return res;
	}


	virtual TArea& operator =(const TArea& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TArea() {
	}


	TArea(TShapeType _shapeType,  std::vector<TPoint> _points,  std::vector<TArea> _areaSet, 
	        CAGType _cagType,  TColor _background,  TColorGradient _colorPaint): 
	shapeType(_shapeType), points(_points), areaSet(_areaSet), cagType(_cagType), background(_background), colorPaint(_colorPaint) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)shapeType);
		p.pack(points);
		p.pack(areaSet);
		p.pack((int32_t)cagType);
		p.pack(background);
		p.pack(colorPaint);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddshapeType;
		u.unpack(ddshapeType);
		shapeType = (TShapeType)ddshapeType;
		u.unpack(points);
		u.unpack(areaSet);
		int32_t ddcagType;
		u.unpack(ddcagType);
		cagType = (CAGType)ddcagType;
		u.unpack(background);
		u.unpack(colorPaint);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("shapeType", (int32_t)shapeType);
		p.pack("points", points);
		p.pack("areaSet", areaSet);
		p.pack("cagType", (int32_t)cagType);
		p.pack("background", background);
		p.pack("colorPaint", colorPaint);
	}



private:
	TArea& doCopy(const TArea& other) {
		shapeType = other.shapeType;
		points = other.points;
		areaSet = other.areaSet;
		cagType = other.cagType;
		background = other.background;
		colorPaint = other.colorPaint;
		return *this;
	}


};


//////////////////////////////////////////////////////////////

class TCell: public TAbstractVisible {

public:
	FillType fillType;

	TCursor cursor;

	std::vector<TSelectionCriterion> criterionProvider;

	int32_t borderMinPixels;

	AspectKeeper aspectKeeper;

	bool isFocusable;

	std::vector<TBehavior> behavior;

	std::vector<TPlacement> subNodes;

	std::vector<TAnimation> animations;

	TSize absoluteSize;

	std::string getTypeName() {
		return "TCell";
	}


	int32_t getTypeId() {
		return 38;
	}


	static int32_t getStaticId() {
		return 38;
	}


	TCell(): 
	fillType(ShowAll), borderMinPixels(-1), isFocusable(false) {
	}


	TCell(const TCell& other): 
	TAbstractVisible(other) {
		doCopy(other);
	}


	virtual TCell* clone() {
		TCell* res = new TCell();
		*res = *this;
		return res;
	}


	virtual TCell& operator =(const TCell& other) {
		if(this == &other) return *this;
		TAbstractVisible::operator=(other);
		doCopy(other);
		return *this;
	}


	virtual ~TCell() {
	}


	TCell(FillType _fillType,  TCursor _cursor,  std::vector<TSelectionCriterion> _criterionProvider, 
	        int32_t _borderMinPixels,  AspectKeeper _aspectKeeper,  bool _isFocusable, 
	        std::vector<TBehavior> _behavior,  std::vector<TPlacement> _subNodes,  std::vector<TAnimation> _animations, 
	        TSize _absoluteSize): 
	fillType(_fillType), cursor(_cursor), criterionProvider(_criterionProvider), borderMinPixels(_borderMinPixels), aspectKeeper(_aspectKeeper), isFocusable(_isFocusable), behavior(_behavior), subNodes(_subNodes), animations(_animations), absoluteSize(_absoluteSize) {
	}


	virtual void packSub(Packer& p) {
		p.pack((int32_t)fillType);
		p.pack(cursor);
		p.pack(criterionProvider);
		p.pack(borderMinPixels);
		p.pack(aspectKeeper);
		p.pack(isFocusable);
		p.pack(behavior);
		p.pack(subNodes);
		p.pack(animations);
		p.pack(absoluteSize);
	}


	virtual void unpackSub(Unpacker& u) {
		int32_t ddfillType;
		u.unpack(ddfillType);
		fillType = (FillType)ddfillType;
		u.unpack(cursor);
		u.unpack(criterionProvider);
		u.unpack(borderMinPixels);
		u.unpack(aspectKeeper);
		u.unpack(isFocusable);
		u.unpack(behavior);
		u.unpack(subNodes);
		u.unpack(animations);
		u.unpack(absoluteSize);
	}


	virtual void streamSub(XPacker& p) {
		p.pack("fillType", (int32_t)fillType);
		p.pack("cursor", cursor);
		p.pack("criterionProvider", criterionProvider);
		p.pack("borderMinPixels", borderMinPixels);
		p.pack("aspectKeeper", aspectKeeper);
		p.pack("isFocusable", isFocusable);
		p.pack("behavior", behavior);
		p.pack("subNodes", subNodes);
		p.pack("animations", animations);
		p.pack("absoluteSize", absoluteSize);
	}



private:
	TCell& doCopy(const TCell& other) {
		fillType = other.fillType;
		cursor = other.cursor;
		criterionProvider = other.criterionProvider;
		borderMinPixels = other.borderMinPixels;
		aspectKeeper = other.aspectKeeper;
		isFocusable = other.isFocusable;
		behavior = other.behavior;
		subNodes = other.subNodes;
		animations = other.animations;
		absoluteSize = other.absoluteSize;
		return *this;
	}


};

DUCData* DUCData::create(int32_t n) {
	if (n == 37) {
		return new AspectKeeper();
	} else if (n == 20) {
		return new GlyphProperties();
	} else if (n == 22) {
		return new ScaleFit();
	} else if (n == 47) {
		return new T3D();
	} else if (n == 51) {
		return new T3DFog();
	} else if (n == 50) {
		return new T3DLight();
	} else if (n == 48) {
		return new T3DPlacement();
	} else if (n == 46) {
		return new T3DVector();
	} else if (n == 49) {
		return new T3DWorld();
	} else if (n == 1) {
		return new TAbstractVisible();
	} else if (n == 28) {
		return new TAddNode();
	} else if (n == 40) {
		return new TAnimation();
	} else if (n == 41) {
		return new TAnimationTask();
	} else if (n == 18) {
		return new TArc();
	} else if (n == 17) {
		return new TArea();
	} else if (n == 29) {
		return new TAttachNode();
	} else if (n == 33) {
		return new TBehavior();
	} else if (n == 38) {
		return new TCell();
	} else if (n == 52) {
		return new TChannel();
	} else if (n == 53) {
		return new TChannelOperation();
	} else if (n == 54) {
		return new TChannelOperationResponse();
	} else if (n == 2) {
		return new TColor();
	} else if (n == 7) {
		return new TColorGradient();
	} else if (n == 36) {
		return new TCursor();
	} else if (n == 15) {
		return new TCurve();
	} else if (n == 30) {
		return new TDeleteNode();
	} else if (n == 13) {
		return new TEllipse();
	} else if (n == 10) {
		return new TFont();
	} else if (n == 16) {
		return new TGeneralCurve();
	} else if (n == 24) {
		return new TGesture();
	} else if (n == 42) {
		return new TGetResourcesFromUsr();
	} else if (n == 23) {
		return new TImage();
	} else if (n == 25) {
		return new TInformServer();
	} else if (n == 12) {
		return new TLine();
	} else if (n == 45) {
		return new TMIME();
	} else if (n == 19) {
		return new TMargin();
	} else if (n == 11) {
		return new TNone();
	} else if (n == 8) {
		return new TPath();
	} else if (n == 9) {
		return new TPenStroke();
	} else if (n == 35) {
		return new TPlacement();
	} else if (n == 3) {
		return new TPoint();
	} else if (n == 6) {
		return new TPolynomial();
	} else if (n == 14) {
		return new TRectangle();
	} else if (n == 39) {
		return new TReference();
	} else if (n == 31) {
		return new TReplaceNode();
	} else if (n == 44) {
		return new TResourceUnit();
	} else if (n == 26) {
		return new TResponse();
	} else if (n == 27) {
		return new TResponseClosure();
	} else if (n == 34) {
		return new TSelectionCriterion();
	} else if (n == 4) {
		return new TSize();
	} else if (n == 21) {
		return new TText();
	} else if (n == 5) {
		return new TTransformation();
	} else if (n == 32) {
		return new TUpdateNode();
	} else if (n == 43) {
		return new TUploadResources();
	}
	return 0;
}

inline void nb_generate_bridge_factory_info(std::vector<nb_bridge_struct_desc*>& data) {
	nb_bridge_struct_desc* st;
	nb_bridge_field_desc* fd;

	//;
	//         For structure AspectKeeper;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "minAspectRatio";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "maxAspectRatio";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "xLoc";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "yLoc";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 37;
	st->struct_name = "AspectKeeper";
	data.push_back(st);

	//;
	//         For structure GlyphProperties;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "color";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "font";
	fd->field_type_name = "TFont";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "point";
	fd->field_type_name = "TPoint";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 20;
	st->struct_name = "GlyphProperties";
	data.push_back(st);

	//;
	//         For structure ScaleFit;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "scaleFitType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "offOneSide";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "offAnotherSide";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 22;
	st->struct_name = "ScaleFit";
	data.push_back(st);

	//;
	//         For structure T3D;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "name";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "texture";
	fd->field_type_name = "TImage";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "textureInfo";
	fd->field_type_name = "byteArray";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "textureModel";
	fd->field_type_name = "byteArray";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "animation";
	fd->field_type_name = "TAnimation";
	fd->is_array = true;

	st->fields.push_back(fd);

	st->struct_number = 47;
	st->struct_name = "T3D";
	data.push_back(st);

	//;
	//         For structure T3DFog;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "start";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "distance";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "color";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 51;
	st->struct_name = "T3DFog";
	data.push_back(st);

	//;
	//         For structure T3DLight;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "position";
	fd->field_type_name = "T3DVector";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "color";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "rotate";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 50;
	st->struct_name = "T3DLight";
	data.push_back(st);

	//;
	//         For structure T3DPlacement;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "position";
	fd->field_type_name = "T3DVector";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "rotate";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "scale";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "data";
	fd->field_type_name = "T3D";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 48;
	st->struct_name = "T3DPlacement";
	data.push_back(st);

	//;
	//         For structure T3DVector;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "x";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "y";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "z";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 46;
	st->struct_name = "T3DVector";
	data.push_back(st);

	//;
	//         For structure T3DWorld;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "lights";
	fd->field_type_name = "T3DLight";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "objects";
	fd->field_type_name = "T3DPlacement";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "fogs";
	fd->field_type_name = "T3DFog";
	fd->is_array = true;

	st->fields.push_back(fd);

	st->struct_number = 49;
	st->struct_name = "T3DWorld";
	data.push_back(st);

	//;
	//         For structure TAbstractVisible;
	//;
	st = new nb_bridge_struct_desc();
	st->struct_number = 1;
	st->struct_name = "TAbstractVisible";
	data.push_back(st);

	//;
	//         For structure TAddNode;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "data";
	fd->field_type_name = "TPlacement";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 28;
	st->struct_name = "TAddNode";
	data.push_back(st);

	//;
	//         For structure TAnimation;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "beginWhenTime";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "endWhenTime";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "task";
	fd->field_type_name = "TAnimationTask";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "children";
	fd->field_type_name = "TAnimation";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "accumulate";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "repeatCount";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 6;
	fd->field_name = "timeUnit";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 40;
	st->struct_name = "TAnimation";
	data.push_back(st);

	//;
	//         For structure TAnimationTask;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "values";
	fd->field_type_name = "TPlacement";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "calcMode";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "keyTimes";
	fd->field_type_name = "integer";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "keySplines";
	fd->field_type_name = "integer";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "dur";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 41;
	st->struct_name = "TAnimationTask";
	data.push_back(st);

	//;
	//         For structure TArc;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "closedType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "start";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "extent";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "edgeColor";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "background";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "colorPaint";
	fd->field_type_name = "TColorGradient";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 6;
	fd->field_name = "fill";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 18;
	st->struct_name = "TArc";
	data.push_back(st);

	//;
	//         For structure TArea;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "shapeType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "points";
	fd->field_type_name = "TPoint";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "areaSet";
	fd->field_type_name = "TArea";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "cagType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "background";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "colorPaint";
	fd->field_type_name = "TColorGradient";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 17;
	st->struct_name = "TArea";
	data.push_back(st);

	//;
	//         For structure TAttachNode;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "parent";
	fd->field_type_name = "TPath";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "id";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "order";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "source";
	fd->field_type_name = "TPath";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 29;
	st->struct_name = "TAttachNode";
	data.push_back(st);

	//;
	//         For structure TBehavior;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "gestureType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "informServer";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "actionTypes";
	fd->field_type_name = "TResponse";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "passThrough";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 33;
	st->struct_name = "TBehavior";
	data.push_back(st);

	//;
	//         For structure TCell;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "fillType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "cursor";
	fd->field_type_name = "TCursor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "criterionProvider";
	fd->field_type_name = "TSelectionCriterion";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "borderMinPixels";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "aspectKeeper";
	fd->field_type_name = "AspectKeeper";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "isFocusable";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 6;
	fd->field_name = "behavior";
	fd->field_type_name = "TBehavior";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 7;
	fd->field_name = "subNodes";
	fd->field_type_name = "TPlacement";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 8;
	fd->field_name = "animations";
	fd->field_type_name = "TAnimation";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 9;
	fd->field_name = "absoluteSize";
	fd->field_type_name = "TSize";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 38;
	st->struct_name = "TCell";
	data.push_back(st);

	//;
	//         For structure TChannel;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "type";
	fd->field_type_name = "TMIME";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "id";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "name";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "url";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "port";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "path";
	fd->field_type_name = "TPath";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 52;
	st->struct_name = "TChannel";
	data.push_back(st);

	//;
	//         For structure TChannelOperation;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "operationType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "channel_or_group_id";
	fd->field_type_name = "integer";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "channels";
	fd->field_type_name = "TChannel";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "data";
	fd->field_type_name = "byteArray";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 53;
	st->struct_name = "TChannelOperation";
	data.push_back(st);

	//;
	//         For structure TChannelOperationResponse;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "operationType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "channelGroupId";
	fd->field_type_name = "integer";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "channels";
	fd->field_type_name = "TChannel";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "data";
	fd->field_type_name = "byteArray";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "responseType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 54;
	st->struct_name = "TChannelOperationResponse";
	data.push_back(st);

	//;
	//         For structure TColor;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "r";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "g";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "b";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "a";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 2;
	st->struct_name = "TColor";
	data.push_back(st);

	//;
	//         For structure TColorGradient;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "p1";
	fd->field_type_name = "TPoint";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "c1";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "p2";
	fd->field_type_name = "TPoint";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "c2";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "distribution";
	fd->field_type_name = "TPolynomial";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 7;
	st->struct_name = "TColorGradient";
	data.push_back(st);

	//;
	//         For structure TCursor;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "cursorType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "image";
	fd->field_type_name = "TImage";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "hotspot";
	fd->field_type_name = "TPoint";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "size";
	fd->field_type_name = "TSize";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 36;
	st->struct_name = "TCursor";
	data.push_back(st);

	//;
	//         For structure TCurve;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "points";
	fd->field_type_name = "TPoint";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "pointsType";
	fd->field_type_name = "boolean";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "curves";
	fd->field_type_name = "TCurve";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "curveType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "stroke";
	fd->field_type_name = "TPenStroke";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "color";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 6;
	fd->field_name = "closed";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 15;
	st->struct_name = "TCurve";
	data.push_back(st);

	//;
	//         For structure TDeleteNode;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "path";
	fd->field_type_name = "TPath";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 30;
	st->struct_name = "TDeleteNode";
	data.push_back(st);

	//;
	//         For structure TEllipse;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "stroke";
	fd->field_type_name = "TPenStroke";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "edgeColor";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "background";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "colorPaint";
	fd->field_type_name = "TColorGradient";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "fill";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 13;
	st->struct_name = "TEllipse";
	data.push_back(st);

	//;
	//         For structure TFont;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "name";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "style";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "size";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 10;
	st->struct_name = "TFont";
	data.push_back(st);

	//;
	//         For structure TGeneralCurve;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "points";
	fd->field_type_name = "TPoint";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "pointsType";
	fd->field_type_name = "boolean";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "curves";
	fd->field_type_name = "TGeneralCurve";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "curveType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "stroke";
	fd->field_type_name = "TPenStroke";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "color";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 6;
	fd->field_name = "fillColor";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 7;
	fd->field_name = "fill";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 8;
	fd->field_name = "closed";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 16;
	st->struct_name = "TGeneralCurve";
	data.push_back(st);

	//;
	//         For structure TGesture;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "type";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "modifier";
	fd->field_type_name = "integer";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "text";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "path";
	fd->field_type_name = "TPath";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "positions";
	fd->field_type_name = "TPoint";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "positionOnRoot";
	fd->field_type_name = "TPoint";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 6;
	fd->field_name = "offSet";
	fd->field_type_name = "TSize";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 7;
	fd->field_name = "resources";
	fd->field_type_name = "TResourceUnit";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 8;
	fd->field_name = "scale";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 9;
	fd->field_name = "visualSizes";
	fd->field_type_name = "TSize";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 10;
	fd->field_name = "viewVersion";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 24;
	st->struct_name = "TGesture";
	data.push_back(st);

	//;
	//         For structure TGetResourcesFromUsr;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "path";
	fd->field_type_name = "TPath";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "resourceType";
	fd->field_type_name = "TMIME";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "multiSelectionEnabled";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 42;
	st->struct_name = "TGetResourcesFromUsr";
	data.push_back(st);

	//;
	//         For structure TImage;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "content";
	fd->field_type_name = "byteArray";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "xDirection";
	fd->field_type_name = "ScaleFit";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "yDirection";
	fd->field_type_name = "ScaleFit";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "relationship";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 23;
	st->struct_name = "TImage";
	data.push_back(st);

	//;
	//         For structure TInformServer;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "gesture";
	fd->field_type_name = "TGesture";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 25;
	st->struct_name = "TInformServer";
	data.push_back(st);

	//;
	//         For structure TLine;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "stroke";
	fd->field_type_name = "TPenStroke";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "color";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 12;
	st->struct_name = "TLine";
	data.push_back(st);

	//;
	//         For structure TMIME;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "type_subType";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 45;
	st->struct_name = "TMIME";
	data.push_back(st);

	//;
	//         For structure TMargin;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "off_left";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "off_right";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "off_up";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "off_down";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 19;
	st->struct_name = "TMargin";
	data.push_back(st);

	//;
	//         For structure TNone;
	//;
	st = new nb_bridge_struct_desc();
	st->struct_number = 11;
	st->struct_name = "TNone";
	data.push_back(st);

	//;
	//         For structure TPath;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "node";
	fd->field_type_name = "integer";
	fd->is_array = true;

	st->fields.push_back(fd);

	st->struct_number = 8;
	st->struct_name = "TPath";
	data.push_back(st);

	//;
	//         For structure TPenStroke;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "width";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "dashPattern";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 9;
	st->struct_name = "TPenStroke";
	data.push_back(st);

	//;
	//         For structure TPlacement;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "path";
	fd->field_type_name = "TPath";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "order";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "display";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "position";
	fd->field_type_name = "TPoint";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "referencePoint";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "referencePointDerivation";
	fd->field_type_name = "integer";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 6;
	fd->field_name = "size";
	fd->field_type_name = "TSize";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 7;
	fd->field_name = "widthValueType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 8;
	fd->field_name = "heightValueType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 9;
	fd->field_name = "transformation";
	fd->field_type_name = "TTransformation";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 10;
	fd->field_name = "relativeValueDerivation";
	fd->field_type_name = "integer";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 11;
	fd->field_name = "matchedCriterion";
	fd->field_type_name = "TSelectionCriterion";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 12;
	fd->field_name = "data";
	fd->field_type_name = "TAbstractVisible";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 13;
	fd->field_name = "innerOffset";
	fd->field_type_name = "TSize";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 14;
	fd->field_name = "scale";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 35;
	st->struct_name = "TPlacement";
	data.push_back(st);

	//;
	//         For structure TPoint;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "x";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "y";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 3;
	st->struct_name = "TPoint";
	data.push_back(st);

	//;
	//         For structure TPolynomial;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "type";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "c";
	fd->field_type_name = "float";
	fd->is_array = true;

	st->fields.push_back(fd);

	st->struct_number = 6;
	st->struct_name = "TPolynomial";
	data.push_back(st);

	//;
	//         For structure TRectangle;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "stroke";
	fd->field_type_name = "TPenStroke";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "edgeColor";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "background";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "colorPaint";
	fd->field_type_name = "TColorGradient";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "roundRadius";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "fill";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 14;
	st->struct_name = "TRectangle";
	data.push_back(st);

	//;
	//         For structure TReference;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "path";
	fd->field_type_name = "TPath";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 39;
	st->struct_name = "TReference";
	data.push_back(st);

	//;
	//         For structure TReplaceNode;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "data";
	fd->field_type_name = "TPlacement";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 31;
	st->struct_name = "TReplaceNode";
	data.push_back(st);

	//;
	//         For structure TResourceUnit;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "fileName";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "data";
	fd->field_type_name = "byteArray";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "resourceType";
	fd->field_type_name = "TMIME";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 44;
	st->struct_name = "TResourceUnit";
	data.push_back(st);

	//;
	//         For structure TResponse;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "responseType";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "data";
	fd->field_type_name = "TPlacement";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 26;
	st->struct_name = "TResponse";
	data.push_back(st);

	//;
	//         For structure TResponseClosure;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "data";
	fd->field_type_name = "TResponse";
	fd->is_array = true;

	st->fields.push_back(fd);

	st->struct_number = 27;
	st->struct_name = "TResponseClosure";
	data.push_back(st);

	//;
	//         For structure TSelectionCriterion;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "name";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "importance";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "member";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 34;
	st->struct_name = "TSelectionCriterion";
	data.push_back(st);

	//;
	//         For structure TSize;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "width";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "height";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 4;
	st->struct_name = "TSize";
	data.push_back(st);

	//;
	//         For structure TText;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "text";
	fd->field_type_name = "string";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "glyphProperties";
	fd->field_type_name = "GlyphProperties";
	fd->is_array = true;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "color";
	fd->field_type_name = "TColor";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "font";
	fd->field_type_name = "TFont";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "margin";
	fd->field_type_name = "TMargin";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "layout";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 6;
	fd->field_name = "localEditable";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 7;
	fd->field_name = "wraparound";
	fd->field_type_name = "boolean";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 21;
	st->struct_name = "TText";
	data.push_back(st);

	//;
	//         For structure TTransformation;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "scaleX";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "scaleY";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 2;
	fd->field_name = "shearX";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 3;
	fd->field_name = "shearY";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 4;
	fd->field_name = "offsetX";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 5;
	fd->field_name = "offsetY";
	fd->field_type_name = "integer";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 5;
	st->struct_name = "TTransformation";
	data.push_back(st);

	//;
	//         For structure TUpdateNode;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "data";
	fd->field_type_name = "TPlacement";
	fd->is_array = false;

	st->fields.push_back(fd);

	st->struct_number = 32;
	st->struct_name = "TUpdateNode";
	data.push_back(st);

	//;
	//         For structure TUploadResources;
	//;
	st = new nb_bridge_struct_desc();
	fd = new nb_bridge_field_desc();
	fd->field_number = 0;
	fd->field_name = "path";
	fd->field_type_name = "TPath";
	fd->is_array = false;

	st->fields.push_back(fd);

	fd = new nb_bridge_field_desc();
	fd->field_number = 1;
	fd->field_name = "resources";
	fd->field_type_name = "TResourceUnit";
	fd->is_array = true;

	st->fields.push_back(fd);

	st->struct_number = 43;
	st->struct_name = "TUploadResources";
	data.push_back(st);
}


#endif

